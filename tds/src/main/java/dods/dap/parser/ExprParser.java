/* Generated By:JavaCC: Do not edit this line. ExprParser.java */
package dods.dap.parser;

import java.util.Vector;
import java.util.Stack;

import dods.dap.*;
import dods.dap.Server.*;

/** The constraint expression parser class. <p>
    
    Because it only makes sense to evaluate CEs when serving data, the
    BaseTyeFactory <em>must</em> create instances of the SDtype classes, not
    the Dtype classes. The is because we use the setRead method of the class
    ServerMethods when creating constants (to ensure that the evaluator
    doesn't try to read tem from the dataset!).
    
    @author jhrg */

public class ExprParser implements ExprParserConstants {
    private ServerDDS sdds;
    private CEEvaluator ceEval;
    private BaseTypeFactory factory;
    private ClauseFactory clauseFactory;

    /** Run the named projection function. Projection functions are run for
	their side effect; the return value is discarded. 
	@param name The name of the projection function, look this up in the
	ServerDDS. 
	@param btv A vector of BaseType variables that are the arguments of
	the projection function. */
    private void runProjectionFunction(String name, Vector btv) {
    }

    /** Remove double quotes from around a string. If there's not both start
	and ending quotes, does nothing.
	@param s The source string.
	@return The string without double quotes. */
    private String removeQuotes(String s) {
        if (s.startsWith("\"") && s.endsWith("\""))
            return s.substring(1, s.length() - 1);
        else
            return s;
    }

    /** Given a stack of BaseType variables, mark these as part of the
     * current projection. This function assumes that if the TOS contains a
     * Ctor type variable, all of its members are to be projected. Also
     * assume  all variables under the TOS are Ctor variables and
     * only the ctor itself is to be projected; the member within the Ctor
     * that is part of the projection will be on the stack, too. */
    private void markStackedVariables(Stack s) {
        // Reverse the stack.
        Stack bts = new Stack();
        // System.err.println("Variables to be marked:");
        while (!s.empty()) {
            // System.err.println(((BaseType)s.peek()).getName());
            bts.push(s.pop());
        }

        // For each but the last stack element, set the projection.
        // setProject(true, false) for a ctor type sets the projection for
        // the ctor itself but *does not* set the projection for all its
        // children. Thus, if a user wants the variable S.X, and S contains Y
        // and Z too, S's projection will be set (so serialize will descend
        // into S) but X, Y and Z's projection remain clear. In this example,
        // X's projection is set by the code that follows the while loop.
        // 1/28/2000 jhrg
        while (bts.size() > 1) {
            ServerMethods ct = (ServerMethods)bts.pop();
            ct.setProject(true, false);
        }

        // For the last element, project the entire variable.
        ServerMethods bt = (ServerMethods)bts.pop();
        bt.setProject(true, true);
    }

/** This is the entry point for the Constraint expression parser.<p>

    Note that this method catches any ParserException and recasts it to a
    DODSException after replacing all double quotes with single quotes.

    @param ceEval A CEEvaluator instance where any select clauses will be
    dumped and from which the DDS, which supplies the evaluation environment,
    will be read.
    @param factory A BaseTypeFactory used to generate instances of variables
    as needed (e.g., to hold values of constants).
    @param clauseFactory A ClauseFactory used to generate instances of each
    type of clause. */
  final public void constraint_expression(CEEvaluator ceEval, BaseTypeFactory factory,
                           ClauseFactory clauseFactory) throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, DODSException, InvalidParameterException, SBHException, WrongTypeException {
    this.ceEval = ceEval;
    this.sdds = ceEval.getDDS();
    this.factory = factory;
    this.clauseFactory = clauseFactory;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        projection();
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AMPERSAND:
            ;
            break;
          default:
            jj_la1[0] = jj_gen;
            break label_1;
          }
          selection();
        }
        break;
      default:
        jj_la1[2] = jj_gen;
                ceEval.markAll(true); // No projection; mark all

        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AMPERSAND:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_2;
          }
          selection();
        }
      }
    } catch (ParseException pe) {
        // Extract the message and rethrow after changing all the double
        // quotes to single quotes so that the code that (might) send the
        // text of this exception back to a client over the network won't
        // barf. 
        String msg = pe.getMessage();
        if (msg != null)
            msg = msg.replace('\"', '\'');
        {if (true) throw new DODSException(DODSException.MALFORMED_EXPR, msg);}
    }
  }

  final public void selection() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, SBHException, DODSException {
    Clause c;
    jj_consume_token(AMPERSAND);
    c = clause();
        ceEval.appendClause(c);
  }

  final public Clause clause() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, DODSException {
    Clause c;
    SubClause lop, rop;
    Vector ropv;
    int op;
    if (jj_2_1(2)) {
      c = bool_function();
        {if (true) return c;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
      case ID:
      case INT:
      case FLOAT:
      case STR:
        lop = value();
        op = rel_op();
                                   ropv = new Vector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASTERISK:
        case ID:
        case INT:
        case FLOAT:
        case STR:
          rop = value();
                           ropv.addElement(rop);
          break;
        case LBRACE:
          jj_consume_token(LBRACE);
          label_3:
          while (true) {
            rop = value();
                                       ropv.addElement(rop);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              jj_consume_token(COMMA);
              break;
            default:
              jj_la1[3] = jj_gen;
              ;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ASTERISK:
            case ID:
            case INT:
            case FLOAT:
            case STR:
              ;
              break;
            default:
              jj_la1[4] = jj_gen;
              break label_3;
            }
          }
          jj_consume_token(RBRACE);
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        {if (true) return clauseFactory.newRelOpClause(op, lop, ropv);}
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Clause bool_function() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, DODSException {
    Token name;                 // Name of the function
    Vector btv;
    name = jj_consume_token(ID);
    btv = arg_list();
        {if (true) return clauseFactory.newBoolFunctionClause(name.image, btv);}
    throw new Error("Missing return statement in function");
  }

// Note that I'm using the constants from the ExprParserConstants interface
// rather than (re)define a new set of constants. 7/20/99 jhrg
  final public int rel_op() throws ParseException {
    Token op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      op = jj_consume_token(EQUAL);
      {if (true) return op.kind;}
      break;
    case NOT_EQUAL:
      op = jj_consume_token(NOT_EQUAL);
      {if (true) return op.kind;}
      break;
    case GREATER:
      op = jj_consume_token(GREATER);
      {if (true) return op.kind;}
      break;
    case GREATER_EQL:
      op = jj_consume_token(GREATER_EQL);
      {if (true) return op.kind;}
      break;
    case LESS:
      op = jj_consume_token(LESS);
      {if (true) return op.kind;}
      break;
    case LESS_EQL:
      op = jj_consume_token(LESS_EQL);
      {if (true) return op.kind;}
      break;
    case REGEXP:
      op = jj_consume_token(REGEXP);
      {if (true) return op.kind;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void projection() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, InvalidParameterException, SBHException, WrongTypeException, DODSException {
    proj_clause();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      proj_clause();
    }
  }

// Note that we have to keep a count of the array index number for the calls
// to array_index(). 7/20/99 jhrg
  final public void proj_clause() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, InvalidParameterException, SBHException, WrongTypeException, DODSException {
    Token t;
    Vector btv;
    if (jj_2_2(2)) {
      t = jj_consume_token(ID);
      btv = arg_list();
        ceEval.appendClause(clauseFactory.newBTFunctionClause(t.image, btv));
        // runProjectionFunction(t.image, btv);

    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        proj_variable();
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void proj_variable() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, InvalidParameterException, SBHException, WrongTypeException, DODSException {
    Token t;
    BaseType bt;
    Stack comp = new Stack();
    comp = component(comp);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
      jj_consume_token(SEPARATOR);
      comp = component(comp);
    }
        markStackedVariables(comp);
  }

  final public Stack component(Stack components) throws ParseException, ParseException, DODSException {
    Token t;
    int count = 0;
    ServerArrayMethods abt;
    if (jj_2_3(2)) {
      t = jj_consume_token(ID);
        components = sdds.search(t.image, components);
        try {
            abt = (ServerArrayMethods)components.peek();
        }
        catch (ClassCastException cce) {
            String msg = "Attempt to treat the variable `" + t.image
            + "' as if it is an array.";
            {if (true) throw new DODSException(DODSException.MALFORMED_EXPR, msg);}
        }
      label_6:
      while (true) {
        array_index(count++, abt);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
      }
        {if (true) return components;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        t = jj_consume_token(ID);
        components = sdds.search(t.image, components);
        {if (true) return components;}
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Vector arg_list() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, ParseException, DODSException {
    Vector cv = new Vector();
    Clause c;
    jj_consume_token(LPAREN);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
      case ID:
      case INT:
      case FLOAT:
      case STR:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_7;
      }
      c = value();
                           cv.addElement(c);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
    }
    jj_consume_token(RPAREN);
              {if (true) return cv;}
    throw new Error("Missing return statement in function");
  }

// Note that we must explicitly catch the NumberFormatExceptions since it is
// a child of RuntimeException. Might as well do it here and munge the
// message into a DODSException object. 1/6/2000 jhrg 
  final public void array_index(int count, ServerArrayMethods bt) throws ParseException, ParseException, DODSException, InvalidParameterException, SBHException {
    Token t1, t2, t3;
    if (jj_2_4(5)) {
      jj_consume_token(LBRACKET);
      t1 = jj_consume_token(INT);
      jj_consume_token(COLON);
      t2 = jj_consume_token(INT);
      jj_consume_token(COLON);
      t3 = jj_consume_token(INT);
      jj_consume_token(RBRACKET);
        try {
            bt.setProjection(count, Integer.parseInt(t1.image),
                             Integer.parseInt(t2.image),
                             Integer.parseInt(t3.image) );
        }
        catch (NumberFormatException e) {
            {if (true) throw new DODSException(DODSException.MALFORMED_EXPR,
"Could not parse one of " + t1.image + ", " + t2.image + ", " + t3.image +
" as an integer: " + e.getMessage());}
        }
    } else if (jj_2_5(3)) {
      jj_consume_token(LBRACKET);
      t1 = jj_consume_token(INT);
      jj_consume_token(COLON);
      t2 = jj_consume_token(INT);
      jj_consume_token(RBRACKET);
          try {
              bt.setProjection(count, Integer.parseInt(t1.image), 1,
                               Integer.parseInt(t2.image) );
          }
          catch (NumberFormatException e) {
              {if (true) throw new DODSException(DODSException.MALFORMED_EXPR,
"Could not parse one of " + t1.image + ", " + t2.image +
" as an integer: " + e.getMessage());}
          }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        jj_consume_token(LBRACKET);
        t1 = jj_consume_token(INT);
        jj_consume_token(RBRACKET);
           try {
               bt.setProjection(count, Integer.parseInt(t1.image), 1,
                                Integer.parseInt(t1.image) );
           }
           catch (NumberFormatException e) {
               {if (true) throw new DODSException(DODSException.MALFORMED_EXPR,
"Could not parse " + t1.image + " as an integer: " + e.getMessage());}
           }
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

// Values only appear in the selection part of a CE. 
// Use clauseFactory to create the appropriate type of clause - joew
  final public SubClause value() throws ParseException, NoSuchVariableException, NoSuchFunctionException, InvalidOperatorException, DODSException, ParseException {
    Token t;
    Vector btv;
    BaseType bt;
    String name;
    Stack comp = new Stack();
    if (jj_2_6(2)) {
      jj_consume_token(ASTERISK);
      comp = component(comp);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEPARATOR:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_8;
        }
        jj_consume_token(SEPARATOR);
        comp = component(comp);
      }
        bt = (BaseType)comp.pop();
        try {
            {if (true) return clauseFactory.newDereferenceClause(((DURL)bt).getValue());}
        } catch (ClassCastException cce) {
          {if (true) throw new DODSException("Attempt to reference non-URL component " +
                                  bt.getName() + " as a URL.");}
        }
    } else if (jj_2_7(2)) {
      jj_consume_token(ASTERISK);
      t = jj_consume_token(STR);
        {if (true) return clauseFactory.newDereferenceClause(t.image);}
    } else if (jj_2_8(2)) {
      t = jj_consume_token(ID);
      btv = arg_list();
        {if (true) return clauseFactory.newBTFunctionClause(t.image, btv);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        comp = component(comp);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEPARATOR:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_9;
          }
          jj_consume_token(SEPARATOR);
          comp = component(comp);
        }
        bt = (BaseType)comp.pop();
        {if (true) return clauseFactory.newValueClause(bt, false);}
        break;
      case INT:
      case FLOAT:
      case STR:
        bt = constant();
        {if (true) return clauseFactory.newValueClause(bt, true);}
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String field() throws ParseException, ParseException {
    String name;
    Token t;
    t = jj_consume_token(ID);
        name = t.image;
    label_10:
    while (true) {
      jj_consume_token(SEPARATOR);
      t = jj_consume_token(ID);
            name += "." + t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_10;
      }
    }
        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

// See my comment above about the NumberFormatExceptions. 8/20/99 jhrg
  final public BaseType constant() throws ParseException, DODSException, ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      t = jj_consume_token(INT);
        //System.out.println("Setting constant value: "+t.image + " (<INT>)");
        DInt32 i = factory.newDInt32("constant");
        try {
            i.setValue(Integer.parseInt(t.image));
            ((ServerMethods)i).setRead(true);
            ((ServerMethods)i).setProject(true);

           // System.out.print("Set value of BaseType. from printVal(): ");
           // i.printVal(System.out,"");
           // System.out.println(" from getValue(): " + i.getValue());
        }
        catch (NumberFormatException e) {
            {if (true) throw new DODSException(DODSException.MALFORMED_EXPR,
            "Could not parse `" + t.image + "' as an integer: " + e.getMessage());}
        }
        {if (true) return i;}
      break;
    case FLOAT:
      t = jj_consume_token(FLOAT);
        System.out.println("Setting constant value: "+t.image + " (<FLOAT>)");
        DFloat64 f = factory.newDFloat64("constant");
        try {
            f.setValue(Double.valueOf(t.image).doubleValue());
            ((ServerMethods)f).setRead(true);
            ((ServerMethods)f).setProject(true);

            //System.out.print("Set value of BaseType to: ");
            //f.printVal(System.out,"");
            //System.out.println("");
        }
        catch (NumberFormatException e) {
            {if (true) throw new DODSException(DODSException.MALFORMED_EXPR,
            "Could not parse `" + t.image + "' as an integer: " + e.getMessage());}
        }
        {if (true) return f;}
      break;
    case STR:
      t = jj_consume_token(STR);
        System.out.println("Setting constant value: "+t.image + " (<STR>)");
        DString s = factory.newDString("constant");
        s.setValue(removeQuotes(t.image));
        ((ServerMethods)s).setRead(true);
        ((ServerMethods)s).setProject(true);

        //System.out.print("Set value of BaseType to: ");
        //s.printVal(System.out,"");
        //System.out.println("");

        {if (true) return s;}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_15()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_12()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_11()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_12()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    if (jj_3R_13()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_13()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(STR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_12()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public ExprParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[21];
  final private int[] jj_la1_0 = {0x20000,0x20000,0x800000,0x10000,0x13808000,0x13908000,0x13808000,0xfe0,0x10000,0x800000,0x400000,0x1000,0x800000,0x13808000,0x10000,0x1000,0x400000,0x400000,0x13800000,0x400000,0x13000000,};
  final private JJCalls[] jj_2_rtns = new JJCalls[8];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public ExprParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ExprParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ExprParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ExprParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ExprParser(ExprParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ExprParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration en = jj_expentries.elements(); en.hasMoreElements();) {
        int[] oldentry = (int[])(en.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[32];
    for (int i = 0; i < 32; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 21; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 32; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 8; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
