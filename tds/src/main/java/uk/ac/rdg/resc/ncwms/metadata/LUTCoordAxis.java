/*
 * Copyright (c) 2007 The University of Reading
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University of Reading, nor the names of the
 *    authors or contributors may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package uk.ac.rdg.resc.ncwms.metadata;

import com.sleepycat.persist.model.Persistent;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import ucar.nc2.constants.AxisType;

/**
 * Coordinate axis defined by a look-up table, as generated by Greg Smith's code
 *
 * @author Jon Blower
 * $Revision$
 * $Date$
 * $Log$
 */
@Persistent
public class LUTCoordAxis extends TwoDCoordAxis
{
  static private org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(LUTCoordAxis.class);

    /**
     * Maps filenames to axes
     */
    private static final Map<String, LUTCoordAxis> lutAxes =
        new HashMap<String, LUTCoordAxis>();
    
    private String filename;
    private short[] indices;
    private Regular1DCoordAxis xAxis, yAxis; // Used to convert from projection coordinates
                                             // to LUT index
    
    /**
     * Creates a LUTCoordAxis from the LUT in the given filename.  If an
     * LUTCoordAxis has already been generated by this filename, this returns it.
     * Using this method presupposes that the LUT is defined on the basis of
     * converting lat and lon to data indices (as opposed to coordinates in some
     * other projection).
     * @param filename Name of the file containing the LUT data
     * @param type Type of this axis (GeoX or GeoY)
     * @throws IOException if there was an error reading from the file
     */
    public static LUTCoordAxis createAxis(String filename, AxisType type) throws IOException
    {
        return createAxis(filename, type, true);
    }
    
    /**
     * Creates a LUTCoordAxis from the LUT in the given filename.  If an
     * LUTCoordAxis has already been generated by this filename, this returns it.
     * This method is thread-safe, so an axis will not be created multiple times.
     * @param filename Name of the file containing the LUT data
     * @param type Type of this axis (GeoX or GeoY)
     * @param lutIsLatLon True if the LUT is defined on the basis of converting
     * lat-lon to data indices.  (This will usually be true - there probably isn't
     * much point in defining the LUT on the basis of other coordinate systems.)
     * @throws IOException if there was an error reading from the file
     */
    public static LUTCoordAxis createAxis(String filename, AxisType type,
        boolean lutIsLatLon) throws IOException
    {
        // This synchronization ensures that only one LUT can be loaded at a time.
        // This is effective but heavy-handed as it prevents two different axes
        // being loaded simultaneously (which would be legitimate).
        synchronized(lutAxes)
        {
            if (!lutAxes.containsKey(filename))
            {
                InputStream in = null;
                File file = new File(filename);
                File parentFile = file.getParentFile();
                if (parentFile == null)
                {
                    throw new FileNotFoundException(filename);
                }
                else if (parentFile.getPath().endsWith(".zip"))
                {
                    InputStream zipIn = in = Thread.currentThread()
                        .getContextClassLoader().getResourceAsStream(parentFile.getPath());
                    in = new ZipInputStream(zipIn);
                    // Skip to the required entry
                    while (true)
                    {
                        ZipEntry entry = ((ZipInputStream)in).getNextEntry();
                        if (entry == null)
                        {
                            // We have gone past the last entry
                            throw new FileNotFoundException(file.getName() +
                                " not found in zip file " + parentFile.getPath());
                        }
                        else if (entry.getName().equals(file.getName()))
                        {
                            break; // exit the loop
                        }
                    }
                }
                else
                {
                    // This is a regular, uncompressed file
                    in = Thread.currentThread().getContextClassLoader()
                        .getResourceAsStream(filename);
                }
                lutAxes.put(filename, createAxis(in, filename, type, lutIsLatLon));
            }
        }
        return lutAxes.get(filename);
    }
    
    /**
     * Creates an LUTCoordAxis
     * @param in InputStream from which to read the look-up table
     * @param filename Name of file from which we are reading
     * @param type The type of this axis
     * @return a newly-created LUTCoordAxis
     */
    private static final LUTCoordAxis createAxis(InputStream in, String filename,
        AxisType type, boolean lutIsLatLon) throws IOException
    {        
        BufferedReader reader = null;
        try
        {
            reader = new BufferedReader(new InputStreamReader(in));
            String line = null;
            
            // Read the header information
            int headerLinesRead = 0;
            double minX = 0.0;
            double maxX = 0.0;
            double minY = 0.0;
            double maxY = 0.0;
            int nx = 0;
            int ny = 0;
            do
            {
                line = reader.readLine();
                // Ignore comment lines
                if (line != null && !line.trim().startsWith("#"))
                {
                    StringTokenizer tok = new StringTokenizer(line);
                    if (tok.countTokens() != 2)
                    {
                        throw new IOException("Header format error in " + filename);
                    }
                    if (headerLinesRead == 0)
                    {
                        // We are reading the x range
                        minX = Double.parseDouble(tok.nextToken());
                        maxX = Double.parseDouble(tok.nextToken());
                    }
                    else if (headerLinesRead == 1)
                    {
                        // We are reading the y range
                        minY = Double.parseDouble(tok.nextToken());
                        maxY = Double.parseDouble(tok.nextToken());
                    }
                    else
                    {
                        // We are reading the number of points in each direction
                        nx = Integer.parseInt(tok.nextToken());
                        ny = Integer.parseInt(tok.nextToken());
                    }
                    headerLinesRead++;
                }
            } while (line != null && headerLinesRead < 3);
            if (headerLinesRead < 3)
            {
                throw new IOException("Header information incomplete in " + filename);
            }
            logger.debug("minX = {}, maxX = {}, minY = {}, maxY {}, nx = {}, ny = {}",
                new Object[]{minX, maxX, minY, maxY, nx, ny});
            
            // Now read the look-up table itself
            int i = 0;
            short[] indices = new short[nx * ny];
            do
            {
                line = reader.readLine();
                // Ignore comment lines that start with #
                if (line != null && !line.trim().startsWith("#"))
                {
                    StringTokenizer tok = new StringTokenizer(line);
                    while(tok.hasMoreTokens())
                    {
                        indices[i] = Short.parseShort(tok.nextToken());
                        // Files were produced using FORTRAN, hence indices are 1-based
                        indices[i] -= 1;
                        i++;
                    }
                }
            } while (line != null);
            logger.debug("Read {} items of lookup data from {}", i, filename);
            // Garbage-collect to try to free some memory
            System.gc();
            return new LUTCoordAxis(type, filename, indices, minX, maxX,
                minY, maxY, nx, ny, lutIsLatLon);
        }
        catch(RuntimeException rte)
        {
            logger.error("Runtime error reading from " + filename + ": ", rte);
            throw rte;
        }
        finally
        {
            if (reader != null)
            {
                // Close the reader, ignoring error messages
                try { reader.close(); } catch (IOException ioe) {}
            }
        }
    }
    
    private LUTCoordAxis(AxisType type, String filename, short[] indices,
        double minX, double maxX, double minY, double maxY, int nx, int ny,
        boolean lutIsLatLon)
    {
        super(type);
        this.filename = filename;
        this.indices = indices;
        double xStride = (maxX - minX) / (nx - 1);
        double yStride = (maxY - minY) / (ny - 1);
        this.xAxis = new Regular1DCoordAxis(minX, xStride, nx,
            lutIsLatLon ? AxisType.Lon : AxisType.GeoX);
        this.yAxis = new Regular1DCoordAxis(minY, yStride, ny,
            lutIsLatLon ? AxisType.Lat : AxisType.GeoY);
    }
    
    public int getIndex(double x, double y)
    {
        int xi = this.xAxis.getIndex(x);
        int yi = this.yAxis.getIndex(y);
        if (xi >= 0 && yi >= 0)
        {
            return this.indices[yi * this.xAxis.getSize() + xi];
        }
        else
        {
            return -1;
        }
    }
    
    public boolean equals(Object obj)
    {
        if (this == obj) return true;
        if (!(obj instanceof LUTCoordAxis)) return false;
        LUTCoordAxis otherAxis = (LUTCoordAxis)obj;
        // Simply compare the filenames: if the axes use the same filename
        // then they contain the same information
        return this.filename.equals(otherAxis.filename);
    }
    
}
