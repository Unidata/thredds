  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
  <title>Tomcat Installation and Configuration</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <style type="text/css">
  * { font-family: "Bitstream Vera Serif",times,serif; }
  body { counter-reset: h1; font-size: 17px; }
  h1:before { content: counter(h1) '. '; counter-increment: h1; }
  h1 { font-size: 1.4em; border-top: 2px solid black; padding-top: 7px; }
  h2 { font-size: 1.2em; }
  h3 { font-size: 1em; font-style: italic; }
  table, tr, th, td { border-collapse: collapse; border: thin black solid; padding: 5px; }
  pre { padding: 0.25em; overflow: auto; width: 90%; font-size: 0.9em; }
  pre.ed { background-color: #EEE; border: 1pt #CCC dotted; }
  pre.cmd { background-color: #111; border: 1pt #666 solid; color: white; }
  pre.browser { background-color: #FFFFBF; border: 1pt #BFBF60 dashed; }
  .alert { color: #C00; font-weight: bold; }
  </style>
  </head>
  <body>
  <p style="font-weight:bold;font-size:2.8em;">Tomcat Installation and Configuration</p>
<p style="font-weight:bold;font-size:2em;">Elliot Smith 2006</p>

	<h1>History</h1>


	<p>Apache Software Foundation (ASF) &#8211; set up in 1999 &#8211; a non-profit organisation to support open source development</p>


	<p>Covers projects like Apache web server, Ant, Xerces, Axis, Geronimo, Struts</p>


	<p>Also has an incubator for experimental bleeding edge projects (including Roller, which we may get round to installing later)</p>


	<p>Jakarta Project &#8211; an <span class="caps">ASF</span> project with around 20 Java subprojects &#8211; Tomcat is one of these</p>


	<p>Tomcat was originated in 1999; it merged together the <span class="caps">ASF</span> JServ Servlet engine (originally designed to integrate with Apache web server) and the Sun Java Web Server</p>


	<p>Tomcat is the reference implementation for Servlet Containers, meaning it has to fully support the latest specifications for Servlet Containers &#8211; more in a moment</p>


	<p>Tomcat 4.0 was released in 2001 (with the code name Catalina, which is why that name is still hanging around)</p>


	<p>Tomcat 5.5 was released end 2005</p>


	<h1>How Java web applications work</h1>


	<p>There is a <strong>Java Servlet Specification</strong> and a <strong><span class="caps">JSP</span> Specification</strong> which define the following precisely. Tomcat 5.5.x supports version <em>2.4</em> of the <strong>Java Servlet Specification</strong> and <em>2.0</em> of the <strong><span class="caps">JSP</span> Specification</strong>.</p>


	<p>You can get the full Servlet Specification from http://java.sun.com/products/servlet/reference/api/index.html.</p>


	<p>And the <span class="caps">JSP</span> specification from http://java.sun.com/products/jsp/reference/api/index.html.</p>


	<h2>Servlets</h2>


	<p><strong>Servlets</strong> are at the core of a Java web application. Each servlet is a chunk of Java code (a class which implements the Servlet interface) which defines a specific set of methods:</p>


	<ul>
	<li><strong>init()</strong>: Called when the servlet is initialise to setup the resources it needs to serve requests.</li>
		<li><strong>service()</strong>: Called each time a request is made to the servlet to generate a response. Each servlet can manage multiple requests.</li>
		<li><strong>destroy()</strong>: Called when the servlet is disposed of to release its resources.</li>
	</ul>


	<p>Servlets are managed by a <strong>servlet container</strong> (Tomcat is one example). When the servlet container starts, it runs the <strong>init()</strong> method for all of the servlets it is managing; it routes requests to appropriate servlets as they come in, calling the <strong>service()</strong> method for each one; and it calls the <strong>destroy()</strong> method for each servlet when the container is stopped.</p>


	<p>As well as providing an environment for managing the lifecycle of servlets, a servlet container also handles sessions for servlets, authentication and authorisation services, and provides access to other resources like databases and directory services.</p>


	<h2>JSPs</h2>


	<p>JSPs were designed to ease development of servlets. They provide a familiar <span class="caps">ASP</span>/PHP style framework for writing web applications, where Java code can be integrated into <span class="caps">HTML</span> code. In the early days of <span class="caps">JSP</span>, it was really close to <span class="caps">ASP</span>; these days, lumps of Java code have been replaced with <strong>tag libraries</strong>: <span class="caps">XML</span>-style markup which is converted behind the scenes into Java code. This makes it easier for designers to work on Java web applications, and also enables better separation of presentation code (in JSPs) from business logic (in servlets).</p>


	<p>Whether tags or literal Java code are included in a <span class="caps">JSP</span> page, the first time a <span class="caps">JSP</span> is requested, it is converted on the fly into servlet code. (This behaviour can be overridden so that JSPs are precompiled, as compilation on the fly is somewhat inefficient and possibly a security hazard.)</p>


	<h2>Web applications</h2>


	<p>Bringing JSPs, servlets and configuration together, a web application has a pre-defined filesystem layout that can be handled by any compliant servlet container:</p>


	<table>
		<tr>
			<td><strong>Relative path</strong></td>
			<td><strong>Purpose</strong></td>
		</tr>
		<tr>
			<td>/</td>
			<td>contains publically accessible files, like JSPs, <span class="caps">HTML</span> pages, images, stylesheets</td>
		</tr>
		<tr>
			<td>/META-INF/MANIFEST.MF</td>
			<td>metadata about the application, e.g. who originated it, its homepage, dependencies on other libraries</td>
		</tr>
		<tr>
			<td>/META-INF/context.xml</td>
			<td>partial deployment descriptor describing the Context for the application (see later)</td>
		</tr>
		<tr>
			<td><span class="caps">WEB</span>-INF</td>
			<td>contains non-public files</td>
		</tr>
		<tr>
			<td>/WEB-INF/web.xml</td>
			<td>deployment descriptor, mapping paths onto servlet classes, defining resources, setting security restrictions</td>
		</tr>
		<tr>
			<td>/WEB-INF/tlds</td>
			<td>tag library definitions</td>
		</tr>
		<tr>
			<td>/WEB-INF/classes</td>
			<td>class files used by the application</td>
		</tr>
		<tr>
			<td>/WEB-INF/lib</td>
			<td>jar files of libraries used by the application</td>
		</tr>
	</table>




	<p>If you have an application structured this way, you can zip it into a file with a .war suffix (a Web ARchive) and deploy it to any compliant servlet container.</p>


	<h2>What about <span class="caps">J2EE</span>?</h2>


	<p>The Servlet and <span class="caps">JSP</span> Specifications are part of the larger <span class="caps">J2EE</span> specification, which includes numerous other APIs, such as:</p>


	<ul>
	<li><strong>Enterprise JavaBeans</strong> for building components which can support transactions, remote method invocation, object/relational mapping, etc.</li>
		<li><strong><span class="caps">JAX</span>-RPC</strong> for binding Java objects to web services.</li>
		<li>etc&#8230;.</li>
	</ul>


	<p>If you need support for these features, JBoss and Geronimo are two open source implementations.</p>


	<h1>Prerequisites</h1>


	<p>I wrote the course using Ubuntu Dapper in August 2006.</p>


	<p>You need the following pieces of software to get Tomcat up and running:</p>


	<ul>
	<li>Java Development Kit: Java 5 is recommended; I use the Sun one from http://java.sun.com/; I got the version 5.0 Update 7 (Linux self-extracting file)</li>
		<li>Tomcat core distribution: http://tomcat.apache.org/. I am using <strong>Tomcat 5.5</strong>.</li>
		<li>Tomcat Administration web application: http://tomcat.apache.org/</li>
	</ul>


	<p>We are going to install these during the course. Download, then verify the integrity of all archives which provide md5 sums, e.g.</p>


<pre class="cmd">
root@lily:/opt/tomcat# md5sum apache-tomcat-5.5.17.tar.gz
994d39c0d2f462c79288e0249991dd49  apache-tomcat-5.5.17.tar.gz
</pre>

	<p>We are also going to look at configuring Tomcat to integrate with the following servers:</p>


	<ul>
	<li>Apache web server (for proxying through to Tomcat for dynamic pages, and serving static pages via Apache): http://apache.org/</li>
		<li>MySQL (as a back-end for Java applications): http://mysql.com/</li>
		<li>Miscellaneous build tools (gcc, make, etc.)</li>
	</ul>


	<p>We&#8217;ll install these via package management on Ubuntu like this:</p>


<pre class="cmd">
apt-get install apache2 mysql-server build-essential
</pre>

	<p>And we are going to install the following application inside Tomcat:</p>


	<ul>
	<li>Roller (http://rollerweblogger.org/page/project), nice Java weblog software</li>
	</ul>


	<p>One other thing we need to do is enable the <strong>universe</strong> and <strong>multiverse</strong> repositories for Ubuntu. We are going to use some packages from these repositories later.</p>


	<h1>Installing Java</h1>


	<p>Switch to the root user</p>


	<p>Make the Java .bin file executable:</p>


<pre class="cmd">chmod +x jdk-1_5_0_07-linux-i586.bin</pre>

	<p>Run the executable:</p>


<pre class="cmd">./jdk-1_5_0_07-linux-i586.bin</pre>

	<p>This prompts you to accept a licence agreement, before unpacking the Java files.</p>


	<p>You can move the extracted directory where you like; we&#8217;ll use <strong>/opt</strong>.</p>


	<p>I like to create a symlink called <strong>/opt/java</strong> which points at the full Java directory.</p>


	<p>Add Java executables to root&#8217;s path (in <strong>/root/.bashrc</strong>), e.g.</p>


<pre class="ed">
export PATH=$PATH:/opt/java/bin
</pre>

	<p>Run Java with:</p>


<pre class="cmd">
java -version
</pre>

	<p>You may find your system has the gcj Java runtime installed, in which case you want to avoid using this as far as possible (it doesn&#8217;t support the full Java library, though Tomcat is supposed to work OK with it). Use:</p>


<pre class="cmd">
which java
</pre>

	<p>to work out which one you&#8217;re using. If you need to, create an alias to ensure the correct Java version is being used, e.g. put this into <strong>/root/.bashrc</strong>:</p>


<pre class="ed">
alias java='/opt/java/bin/java'
</pre>

	<p>I got this as output:</p>


<pre class="cmd">
java version "1.5.0_07" 
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03)
Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode, sharing)
</pre>

	<h1>Installing Tomcat</h1>


	<p>Become root.</p>


	<p>Unpack the tarball into a suitable location. For example, I use <strong>/opt</strong>.</p>


	<p>Create a symlink <strong>/opt/tomcat</strong> which points to your full Tomcat install. This makes upgrading easier, as you can install into a parallel directory, get everything working, copy your applications over, then switch the symlink when ready.</p>


	<p><span class="alert">I&#8217;ll be referring to this directory (/opt/tomcat) as <strong><span class="caps">TOMCAT</span>_HOME</strong> throughout the rest of these notes.</span></p>


	<p>The structure of the installation follows Linux standards fairly closely:</p>


	<ul>
	<li><strong>bin</strong>: shell scripts and batch files for starting/stopping Tomcat</li>
		<li><strong>conf</strong>: configuration files</li>
		<li><strong>logs</strong>: log files</li>
		<li><strong>common</strong>: libraries and classes available to web applications and Catalina</li>
		<li><strong>shared</strong>: libraries and classes available to web applications (not Catalina)</li>
		<li><strong>server</strong>: libraries and classes only available to Catalina; also contains webapps directory with admin. applications (manager, admin once installed)</li>
		<li><strong>work</strong>: where Tomcat stores temporary generated files, e.g. Java classes compiled from JSPs (see next section)</li>
		<li><strong>temp</strong>: not sure&#8230;</li>
		<li><strong>webapps</strong>: where &#8220;end user&#8221; web applications are usually deployed to; each subdirectory represents a single installed application</li>
	</ul>


	<h2>Configuring the start/stop scripts</h2>


	<p>The main start/stop script is <strong>conf/catalina.sh</strong> (in the <strong>bin</strong> directory). We need to make a few modifications to get it working how we want.</p>


	<p>The first thing we need is a reference to our Java installation. Add the following near the top of the file (after the comments):</p>


<pre class="ed">
JAVA_HOME=/opt/java
</pre>

	<p>Once you&#8217;ve done this, you can try it out with:</p>


<pre class="cmd">
./catalina.sh start
</pre>

	<p>This starts Tomcat in its own window (without hanging the current one); effectively as a daemon.</p>


	<p>Check it at <strong>http://localhost:8080/</strong>. You should get the default Tomcat home page.</p>


	<p>To stop it, you can pass the argument <strong>stop</strong> to catalina.sh.</p>


	<p>Other options:</p>


	<ul>
	<li><strong>version</strong>: show version information</li>
		<li><strong>stop -force</strong>: tries to stop Tomcat the usual way, then tries to kill it via pid if it is still hanging around</li>
		<li><strong>start -security</strong>: run with the security manager, which allows very fine-grained permission control over the <span class="caps">JVM</span> (e.g. you can specify which outgoing socket connections are allowed, which applications can write to the filesystem, and so on)</li>
		<li><strong>run</strong>: runs Catalina in the current window without detaching from console</li>
	</ul>


	<h2>Start/stop automatically</h2>


	<p>While you could symlink the catalina.sh script directly into your rc directories, Tomcat would then run as root. It makes sense to run Tomcat with as few privileges as possible (particularly as it normally runs on a high port and doesn&#8217;t need to run as root).</p>


	<p><span class="alert">Stop Tomcat first before doing any of the following!</span></p>


	<p>The first thing I do is create a user and group specifically for tomcat:</p>


<pre class="cmd">
groupadd tomcat
useradd -g tomcat -d /opt/tomcat -s /bin/false tomcat
</pre>

	<p>I then make this user and group the owner of all the files in the install:</p>


<pre class="cmd">
chown -R tomcat.tomcat /opt/apache-tomcat-5.5.17
</pre>

	<p>I then create a new file /etc/init.d/tomcat with my start/stop script in it:</p>


<pre class="ed">
#!/bin/bash
TOMCAT_HOME=/opt/tomcat
# chkconfig: 2345 99 20
# description: Tomcat web server
case "$1" in
'start')
        sudo -u tomcat $TOMCAT_HOME/bin/catalina.sh start
        ;;

'stop')
        sudo -u tomcat $TOMCAT_HOME/bin/catalina.sh stop
        ;;

'restart')
        $0 stop
        $0 start
        ;;
*)
        echo "Usage $0 { start | stop | restart }" 
        exit 1
        ;;
esac
exit 0
</pre>

	<p>This script needs to be executable:</p>


<pre class="cmd">
chmod u+x /etc/init.d/tomcat
</pre>

	<p>To tie it to Ubuntu&#8217;s (or Debian&#8217;s) init process, we can enable it like this:</p>


<pre class="cmd">
update-rc.d tomcat defaults 99 20
</pre>

	<p>This will add required symlinks into /etc/rc*.d directories (start for runlevels 2, 3, 4, and 5, stop at runlevels 0, 1 and 6); start scripts go in at sequence number 99, while stop scripts go in at sequence number 20.</p>


	<p>Try it:</p>


<pre class="cmd">
/etc/init.d/tomcat start
</pre>

	<h2>Locking down permissions</h2>


	<p>You can make the following directories read-only:</p>


	<ul>
	<li>bin</li>
		<li>common</li>
		<li>shared</li>
		<li>server</li>
	</ul>


	<p>You can also disable access to the <strong>conf</strong> directory for non-Tomcat users:</p>


<pre class="cmd">
chmod 700 /opt/tomcat/conf
chmod og-r /opt/tomcat/conf/*
</pre>

	<p>I also make the group sticky on the logs directory, so that any log files are always owned by the tomcat group:</p>


<pre class="cmd">
chmod g+s /opt/tomcat/logs
</pre>

	<h2>Setting <span class="caps">JVM</span> parameters</h2>


	<p>By default, the <span class="caps">JVM</span> will run with the default allocated amount of memory. It will also use the client <span class="caps">JVM</span> (there is also a server one available).</p>


	<p>We can pass custom arguments to the <span class="caps">JVM</span> by setting a <strong><span class="caps">JAVA</span>_OPTS</strong> variable in catalina.sh, e.g.</p>


<pre class="ed">
JAVA_OPTS='-server -Xms256M -Xmx512M'
</pre>

	<p>where:</p>


	<ul>
	<li><strong>-server</strong> switches on the server variant of the <span class="caps">JVM</span>.</li>
		<li><strong>-Xms256M</strong> sets the minimum memory allocation for the <span class="caps">JVM</span> to 256Mb.</li>
		<li><strong>-Xmx512M</strong> sets the maximum memory allocation for the <span class="caps">JVM</span> to 512Mb.</li>
	</ul>


	<p>(with the caveat that if you do any more tweaking it&#8217;s worth doing some performance monitoring to see if it makes any difference)</p>


	<h2>Monitoring processes</h2>


	<p>Here&#8217;s what my Tomcat process looks like (from ps aux):</p>


<pre class="cmd">
tomcat    7543  101  6.4 717156 33300 pts/3    Rl   13:32   \
0:02 /opt/java/bin/java -server -Xms256M -Xmx512M \ 
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager \
-Djava.util.logging.config.file=/opt/tomcat/conf/logging.properties \
-Djava.endorsed.dirs=/opt/tomcat/common/endorsed -classpath \
:/opt/tomcat/bin/bootstrap.jar:/opt/tomcat/bin/commons-logging-api.jar \
-Dcatalina.base=/opt/tomcat -Dcatalina.home=/opt/tomcat \
-Djava.io.tmpdir=/opt/tomcat/temp org.apache.catalina.startup.Bootstrap start
</pre>

	<p>Note that this process is running as the Tomcat user. Also note how the custom <span class="caps">JAVA</span>_OPTS passed to the runtime appear (-server -Xms256M -Xmx512M).</p>


	<p>If you find yourself unable to start Tomcat, it may be that a process like this already exists. You can either try to kill it using the init script or sending a kill signal (<strong>kill -9 7543</strong> in the above case).</p>


	<p>Similarly, if you can&#8217;t stop Tomcat, it might be that the process isn&#8217;t running. You&#8217;ll get an error that looks like this:</p>


<pre class="cmd">
08-Aug-2006 13:33:15 org.apache.catalina.startup.Catalina stopServer
SEVERE: Catalina.stop:
java.net.ConnectException: Connection refused
        at java.net.PlainSocketImpl.socketConnect(Native Method)
        at java.net.PlainSocketImpl.doConnect(Unknown Source)
        at java.net.PlainSocketImpl.connectToAddress(Unknown Source)
</pre>

	<h2>Logging</h2>


	<p>The default logging setup puts the log files into <span class="caps">TOMCAT</span>_HOME/logs. The log configuration is specified in <strong><span class="caps">TOMCAT</span>_HOME/conf/logging.properties</strong>. This file uses the default Java logging infrastructure (see http://java.sun.com/j2se/1.4.2/docs/guide/util/logging/overview.html) to do Tomcat logging, setting up handlers for individual admin. applications and for the server itself.</p>


	<ul>
	<li>Server-level logging is configured by creating entries in <strong>.handlers</strong></li>
		<li>Application-level logging is configured by creating entries in <strong>handlers</strong></li>
	</ul>


	<p>A handler definition looks is composed of two parts.</p>


<ol>
<li>First, the handler is declared:
<pre class="ed">
handlers = 1catalina.org.apache.juli.FileHandler, ...
</pre>
In this case, the name of the handler is <strong>1catalina</strong>. The name must begin with a number, followed by some identifier. Other handlers available:
<ul>
<li><strong>StreamHandler:</strong> A simple handler for writing formatted records to an OutputStream.</li>
<li><strong>ConsoleHandler:</strong> A simple handler for writing formatted records to System.err</li>
<li><strong>SocketHandler:</strong> A handler that writes formatted log records to remote <span class="caps">TCP</span> ports.</li>
<li><strong>MemoryHandler:</strong> A handler that buffers log records in memory.</li>
</ul>
</li>
<li>The second part of the handler definition specifies the properties for logging:
<ul>
<li><strong>level:</strong> available levels are (in increasing verbosity): <span class="caps">OFF</span>, SEVERE, <span class="caps">WARNING</span>, INFO, <span class="caps">CONFIG</span>, FINE, <span class="caps">FINER</span>, FINEST, <span class="caps">ALL</span> </li>
<li><strong>directory:</strong> where to put the logs</li>
<li><strong>prefix</strong> for the log filename</li>
<li><strong>suffix</strong> for the log filename</li>
<li><strong>filter:</strong> you can specify custom filters to screen log messages before writing them to the log</li>
<li><strong>formatter:</strong> the default is the <strong>SimpleFormatter</strong>, but an <strong>XMLFormatter</strong> is also available</li>
</ul>
Here&#8217;s an example of setting the properties for a handler:
<pre class="ed">
1catalina.org.apache.juli.FileHandler.level = FINE
1catalina.org.apache.juli.FileHandler.directory = ${catalina.base}/logs
1catalina.org.apache.juli.FileHandler.prefix = catalina.
</pre>
</li>
</ol>

	<p>The default log files set up in logging.properties are:</p>


	<ol>
	<li>catalina.YYYY-MM-DD.log
General information about the server starting, stopping. The place to look if things are going wrong before the server even starts.</li>
		<li>catalina.out
This file contains the same output as the one above, but will be written to the console if Tomcat is running in console mode (i.e. if you start it with the <strong>run</strong> switch, rather than the <strong>start</strong> switch). The <strong>start</strong> switch detaches the Tomcat process from the console, and writes output to this file instead.</li>
		<li>host-manager, manager, localhost (with date suffixes)
Logs for the built-in web applications.</li>
	</ol>


	<p>It is also possible to specify access logs using <strong>Valve</strong> components (see later).</p>


	<p>For per-application logs, the best approach is to setup logging inside the web application itself using Log4j, perhaps to write into a dedicated log inside the web application&#8217;s directory.</p>


	<h1>Configuring Tomcat</h1>


	<p>Contents of the <strong>conf</strong> directory:</p>


	<ul>
	<li><strong>server.xml</strong>: main server configuration file</li>
		<li><strong>server-minimal.xml</strong>: an example of a minimal server file</li>
		<li><strong>server.xml.2006-08-10.11-18-48</strong>: old versions of the server config. file generated each time you update the server configuration through the Administration interface (see later)</li>
		<li><strong>tomcat-users.xml</strong>: user and role settings for authenticating to applications in the default server setup</li>
		<li><strong>web.xml</strong>: a default deployment descriptor for web applications without their own descriptors</li>
		<li><strong>catalina.policy</strong>: security manager policies</li>
		<li><strong>catalina.properties</strong>: used to define access control policies and custom class loaders</li>
	</ul>


	<p>Reference:
http://localhost:8080/tomcat-docs/config/index.html</p>


	<h2>server.xml</h2>


	<p>The server.xml is the central configuration file for the Tomcat server. It is an <span class="caps">XML</span> file which defines the following top-level components:</p>


	<ul>
	<li>The main tomcat <strong>Server</strong>, which contains:</li>
		<li><strong>Services</strong> on that server (roughly corresponding to a collection of ports which respond to client requests and processors for those requests), which comprises:</li>
		<li><strong>Connectors</strong>, specifying the protocols the Service understands, and where the protocols are accessible; and:</li>
		<li>An <strong>Engine</strong> for the Service, which processes requests for:</li>
		<li>One or more <strong>Hosts</strong> (virtual host definitions)</li>
	</ul>


	<p>Each of these components may additionally contain other elements to refine their behaviour, but this gives an idea of the overall nesting.</p>


	<p>I&#8217;m going to refer to each of the above as <strong>elements</strong> (as each is represented as an <span class="caps">XML</span> element inside the server.xml file).</p>


	<p>One other piece of terminology you may come across is <strong>container</strong>. A container is basically a Tomcat element which can contain other Tomcat elements; technically speaking, Tomcat containers all implement the <strong>org.apache.catalina.Container</strong> interface. The three containers are:</p>


	<ol>
	<li>Engine</li>
		<li>Host</li>
		<li>Context</li>
	</ol>


	<p>To summarise the nesting of elements inside <strong>server.xml</strong> (this is a partial reference and just covers the main elements we are covering):</p>


<pre>
Server
- Listener
- GlobalNamingResources
-- Environment
-- Resource
-- ResourceLink
-- Transaction
- Service
-- Connector
-- Engine
--- Realm
--- Listener
--- Valve
--- Host
---- Alias
---- Realm
---- Listener
---- Valve
---- Context
----- Realm
----- Listener
----- Valve
</pre>

	<p>(<strong>Context</strong> elements are typically configured outside the main server.xml and are covered separately below.)</p>


	<h2>Server</h2>


	<p>Represents the entire Tomcat instance.</p>


	<p>Attributes:</p>


	<ul>
	<li><strong>port</strong>: set the port on which the server will listen for shutdown commands (default: <em>8005</em>).</li>
		<li><strong>shutdown</strong>: if this command string is received via <strong>port</strong> (above), Tomcat will shutdown (default: <em><span class="caps">SHUTDOWN</span></em>).</li>
	</ul>


	<p>The shutdown port can only be used from the host on which Tomcat is running.</p>


	<p>You can test this via telnet:</p>


<pre class="cmd">
telnet localhost 8005
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
SHUTDOWN
Connection closed by foreign host.
</pre>

	<h2>Listener</h2>


	<p>Listeners are used to monitor the state of the server and/or engines. When particular lifecycle events occur (e.g. an <strong>Engine</strong> starts or stops), the listeners can notify their subscribers. In the case of the AprLifecycleListener, for example, the Listener starts and stops the Apache Portable Runtime in sync with the Tomcat server.</p>


	<p>Attributes:</p>


	<ul>
	<li><strong>className</strong>: Class name of the listener.</li>
	</ul>


	<h3>User web applications</h3>


	<p>There is a special Listener class (<strong>org.apache.catalina.startup.UserConfig</strong>) which can be useful in a shared hosting environment as it maps user home directories to URLs. This enables URLs like:</p>


<pre class="browser">
http://localhost:8080/~elliot
</pre>

	<p>to map to a directory like <strong>/home/elliot</strong>.</p>


	<p>More information is available at: http://localhost:8080/tomcat-docs/config/host.html#User%20Web%20Applications</p>


	<h2>GlobalNamingResources</h2>


	<p>Wrappers around global <span class="caps">JNDI</span> resources. <span class="caps">JNDI</span> is a standard Java interface to resources via naming and directory services. In the context of Tomcat, you can use it to create resources which are globally available to any application on the server. The Tomcat Administrator interface divides them into:</p>


	<ul>
	<li><strong>Environment Entries</strong>: Environment variables which can utilised in a web application, e.g. integers or strings.</li>
		<li><strong>User Databases</strong>: Authentication systems which can be used with any application deployed to the server.</li>
		<li><strong>Mail Sessions</strong>: (need mail.jar and activation.jar)</li>
	</ul>


	<p>One of two types of child element can be added to the <strong>GlobalNamingResources</strong> element:</p>


	<ul>
	<li><strong>Environment</strong>: Sets up an environment variable.</li>
		<li><strong>Resource</strong>: Creates a generic resource usable by applications. Once you have created <strong>Resource</strong> entries inside the <strong>GlobalNamingResources</strong> element, you can use a <strong>ResourceLink</strong> element to reference them from inside individual application Contexts (see later).</li>
	</ul>


	<h2>Service</h2>


	<p>A container for connectors. All connectors inside a <strong>Service</strong> share a single <strong>Engine</strong>.</p>


	<p>Attributes:</p>


	<ul>
	<li><strong>name</strong>: name of the service instance, used in log messages (default: <em>Catalina</em>).</li>
	</ul>


	<h2>Connector</h2>


	<p>Represents a service which can allow Tomcat to serve a variety of protocols, for example:</p>


	<ul>
	<li>The <strong><span class="caps">HTTP</span> connector</strong> enables Tomcat to serve <span class="caps">HTTP</span> requests. It listens on a specified <span class="caps">TCP</span> port for <span class="caps">HTTP</span> connections. When connections are made, any <span class="caps">HTTP</span> requests are forwarded to the Service&#8217;s <strong>Engine</strong> component for processing. The <strong>Engine</strong> generates a response which is then returned to the client via the <strong>Connector</strong>.</li>
		<li>The <strong><span class="caps">AJP</span> connector</strong> enables Tomcat to communicate with Apache web server instances. This is one method for fronting a Tomcat installation with an Apache web server.</li>
	</ul>


	<p>All connectors support the following attributes (format of entries in list below: <em><strong>&lt;name of attribute&gt;</strong> (&lt;attribute type&gt;=&lt;default value&gt;): Details</em>):</p>


	<ul>
	<li><strong>allowTrace</strong> (boolean=false): Whether connector should handle the <span class="caps">HTTP TRACE</span> method.</li>
		<li><strong>emptySessionPath</strong> (boolean=false): Set all paths for session cookies to /. Can affect performance if a single client accesses multiple applications on the connector.</li>
		<li><strong>enableLookups</strong> (boolean=true): Lookup the host names of clients connecting to the connector; false will provide better performance (but you only get IP addresses in logs).</li>
		<li><strong>maxPostSize</strong> (int=2097152): Maximum size in bytes that a <span class="caps">POST</span> request body can reach. Set to 0 to make unlimited.</li>
		<li><strong>maxSavePostSize</strong> (int=4096): Maximum size in bytes of the <span class="caps">POST</span> request which will be buffered during authentication of the client. Disable altogether by setting to 0; remove limit on size of <span class="caps">POST</span> by setting to -1.</li>
		<li><strong>protocol</strong> (string): The protocol the Connector manages; set to &#8220;HTTP/1.1&#8221; for the <span class="caps">HTTP</span> Connector, for example.</li>
		<li><strong>proxyName</strong> (string): If this Connector is being used in a proxy configuration, configure this attribute to specify the server name to be returned for calls to request.getServerName().</li>
		<li><strong>proxyPort</strong> (int): If this Connector is being used in a proxy configuration, configure this attribute to specify the server port to be returned for calls to request.getServerPort().</li>
		<li><strong>redirectPort</strong> (int): If this Connector is for non-SSL requests, and a request is received which requires <span class="caps">SSL</span> transport, Catalina will automatically redirect the request to the port number specified here.</li>
		<li><strong>scheme</strong> (string): Set this attribute to the name of the protocol you wish to have returned by calls to request.getScheme(). For example, you would set this attribute to &#8220;https&#8221; for an <span class="caps">SSL</span> Connector. The default value is &#8220;http&#8221;.</li>
		<li><strong>secure</strong> (boolean=false): Set to true if this connector is to be used to serve <span class="caps">SSL</span> connections.</li>
		<li><strong>URIEncoding</strong> (string=&#8221;ISO-8859-1&#8221;): Character encoding to use to decode <span class="caps">URI</span>, after <span class="caps">URL</span>-encoding has been performed.</li>
		<li><strong>useBodyEncodingForURI</strong> (boolean=false): Use the character encoding specified in the request to decode the <span class="caps">URI</span>, rather than the one specified for URIEncoding.</li>
		<li><strong>useIPVHosts</strong> (boolean=false): Use IP-based virtual hosting to route requests, rather than name-based.</li>
		<li><strong>xpoweredBy</strong> (boolean=false): Advertise support for servlets in response headers.</li>
	</ul>


	<h3>The <span class="caps">HTTP</span> connector</h3>


	<p>Connector lifecycle:</p>


	<ol>
	<li>When the server starts, the <span class="caps">HTTP</span> connector spawns a number of request processing threads up to the value of <strong>minSpareThreads</strong>. Each incoming request is handled by a single thread.</li>
		<li>If there are more simultaneous requests than the value of <strong>minSpareThreads</strong>, Tomcat spawns more, up to the value of <strong>maxThreads</strong>.</li>
		<li>If there <strong>maxThreads</strong> is reached and more simultaneous requests need to be handled, Tomcat will &#8220;stack them&#8221; inside the server socket, up to the number specified by <strong>acceptCount</strong>.</li>
		<li>If requests are stacked to the point where <strong>acceptCount</strong> is reached, any further requests get a &#8220;connection refused&#8221; error.</li>
		<li>Once a request has been handled, the thread that was handling it becomes available to handle other requests.</li>
		<li>If the number of spare threads is above <strong>maxSpareThreads</strong>, threads are removed until <strong>maxSpareThreads</strong> is reached.</li>
	</ol>


	<p>Attributes specific to this Connector:</p>


	<ul>
	<li><strong>acceptCount</strong> (int=10): The maximum queue length for incoming connection requests when all possible request processing threads are in use.</li>
		<li><strong>address</strong> (string=all IP addresses associated with server): For servers with more than one IP address, which IP address the port should be opened on.</li>
		<li><strong>bufferSize</strong> (int=2048): Size in bytes of input stream buffers on this connector.</li>
		<li>compressableMimeType (comma-delimited string=&#8221;text/html,text/xml,text/plain&#8221;): List of <span class="caps">MIME</span> types which can have <span class="caps">HTTP</span> compression applied to them.</li>
		<li><strong>compression</strong> (string=&#8221;off&#8221;): Set to &#8220;on&#8221; to enable textual data to be gzip-compressed before sending to client; set to &#8220;force&#8221; to use compression on all data; or set to a numerical value to specify the minimum size in bytes of output which gets compressed (output under this minimum size is not compressed).</li>
		<li><strong>connectionLinger</strong> (int=-1): -1 = no socket linger. Number of milliseconds that sockets used by the connector linger when closed before being destroyed.</li>
		<li><strong>connectionTimeout</strong> (int=60000): Number of seconds the Connector will wait for the initial line of the <span class="caps">HTTP</span> request to be presented after accepting a client connection.</li>
		<li><strong>disableUploadTimeout</strong> (boolean=false): If set to false, servlets get a longer timeout to process uploaded data or simply to run their processes. If set to true, upload timeouts are enabled, so servlets may time out when performing long-running processes.</li>
		<li><strong>maxHttpHeaderSize</strong> (int=4096): The maximum size in bytes of the request and response <span class="caps">HTTP</span> header.</li>
		<li><strong>maxKeepAliveRequests</strong> (int=100): The maximum number of <span class="caps">HTTP</span> requests which can be pipelined until the connection is closed by the server. Setting this attribute to 1 will disable <span class="caps">HTTP</span>/1.0 keep-alive, as well as <span class="caps">HTTP</span>/1.1 keep-alive and pipelining. Setting this to -1 will allow an unlimited amount of pipelined or keep-alive <span class="caps">HTTP</span> requests.</li>
		<li><strong>maxSpareThreads</strong> (int=50): The maximum number of unused request processing threads that will be allowed to exist until the thread pool starts stopping the unnecessary threads.</li>
		<li><strong>maxThreads</strong> (int=200): The maximum number of simultaneous requests the Connector can handle.</li>
		<li><strong>minSpareThreads</strong> (int=4): The number of request-handling threads to start when the Connector starts (should be &lt; <strong>maxThreads</strong> and probably &lt; <strong>maxSpareThreads</strong>).</li>
		<li><strong>noCompressionUserAgents</strong> (comma-separated string=&#8221;&#8220;): Any client whose &#8216;User-Agent&#8217; request header matches one of the regular expressions on this list will not get compressed responses.</li>
		<li><strong>port</strong> (int): The port number the Connector should listen on.</li>
		<li><strong>restrictedUserAgents</strong> (comma-separated string=&#8221;&#8220;): Any client whose &#8216;User-Agent&#8217; request header matches one of the regular expressions in this string will not be allowed to use keep-alive connections.</li>
		<li><strong>server</strong> (string=&#8217;Apache-Coyote/1.1&#8217;): The &#8216;Server&#8217; header to send back with responses.</li>
		<li><strong>socketBuffer</strong> (int=9000): The size in bytes of the socket output buffer. Setting this to -1 disables the buffer.</li>
		<li><strong>strategy</strong> (string=&#8221;lf&#8221;): Sets the thread-spooling strategy.
	<ul>
	<li>&#8220;lf&#8221; = no master thread (all threads listen on the <span class="caps">TCP</span>/IP socket)</li>
		<li>&#8220;ms&#8221; = master listener thread listening on the <span class="caps">TCP</span>/IP socket; use the threadPriority attribute to give the master thread higher priority than the child threads.</li>
	</ul>
	</li>
		<li><strong>tcpNoDelay</strong> (boolean=true): If true, the <span class="caps">TCP</span>_NO_DELAY option is set on the server socket. This improves performance under most circumstances. (If false, Tomcat will wait around buffering small <span class="caps">TCP</span> packets [smaller than the maximum <span class="caps">TCP</span> packet size] and concatenating them into a single larger packet before sending them [Nagle&#8217;s algorithm]. This makes <span class="caps">TCP</span>/IP more efficient for certain applications, but less efficient for web applications.)</li>
		<li><strong>threadPriority</strong> (int=&#8221;java.lang.Thread#NORM_PRIORITY&#8221;): The priority of the request processing threads within the <span class="caps">JVM</span>. Could set to &#8220;java.lang.Thread#MAX_PRIORITY&#8221; to give Tomcat threads priority in the <span class="caps">JVM</span> (over any individual applications). Alternatively, you can specify a number between 1 (lowest priority) and 10 (highest priority).</li>
	</ul>


	<h3>Changing the port</h3>


	<p>Change the port attribute for the Connector, e.g.</p>


<pre class="ed">
&lt;Connector port="8081" minSpareThreads="25" maxThreads="150" maxSpareThreads="75"/&gt;
</pre>

	<p><span class="alert">To run on ports below 1024, you will need to use the root user to run Tomcat.</span></p>


	<h2>Engine</h2>


	<p><span class="alert">Must follow <strong>Connector</strong> elements.</span></p>


	<p>Performs processing of requests forwarded by <strong>Connector</strong> elements.</p>


	<p>Attributes:</p>


	<ul>
	<li><strong>backgroundProcessorDelay</strong> (int=10): This value represents the delay in seconds between the invocation of the backgroundProcess method on the engine and the invocation of background processes by its children (including all hosts and contexts). Set this to a negative value to prevent child containers from having their background processes invoked. Setting this to a positive value will cause Tomcat to spawn a thread. After waiting the specified amount of time, the thread will invoke the backgroundProcess method on this engine and all its children. (The backgroundProcess method is used by Tomcat containers [Engine, Host, Context] to run periodic tasks. For example, a background process may be used to expire sessions, compile <span class="caps">JSP</span> pages, or check for new web applications awaiting deployment.)</li>
		<li><strong>className</strong> (string=&#8221;org.apache.catalina.core.StandardEngine&#8221;): Java class name of the implementation of the <em>org.apache.catalina.Engine</em> interface to use.</li>
		<li><strong>defaultHost</strong> (string=<em>must</em> match a name of a child <strong>Host</strong> element): If a request reaches the server which references a host not defined for this <strong>Engine</strong>, this host is used instead.</li>
		<li><strong>jvmRoute</strong> (string): Used to identify this Engine if it is participating in a clustered setup. Each engine in the cluster has its own unique jvmRoute string. This enables the front-end proxy to forward sessions from clients to the correct back-end Engine.</li>
		<li><strong>name</strong> (string): Name of this Engine, used in log and error messages.</li>
	</ul>


	<h2>Host</h2>


	<p>Specifies a virtual host for this Engine.</p>


	<p>Attributes:</p>


	<ul>
	<li><strong>appBase</strong> (string): The directory containing applications for this host, either an absolute pathname or relative to the root of the Tomcat installation.</li>
		<li><strong>autoDeploy</strong> (boolean=true): Whether to deploy new web applications dropped into <strong>appBase</strong> while Tomcat is running.</li>
		<li><strong>backgroundProcessorDelay</strong> (int=-1): See entry for Engine above; in addition, if set to -1, the Host relies on the parent Engine to run background processes.</li>
		<li><strong>className</strong> (string=&#8221;org.apache.catalina.core.StandardHost&#8221;): Implementation of the org.apache.catalina.Host interface to use.</li>
		<li><strong>deployOnStartup</strong> (boolean=true): Whether web applications for this host should be automatically deployed when the Host starts starts.</li>
		<li><strong>name</strong> (string): Network name for this virtual host, e.g. &#8220;example.com&#8221;. One Host entry must have a name which matches the <strong>defaultHost</strong> setting for the enclosing engine.</li>
	</ul>


	<p>The default Host implementation (<strong>org.apache.catalina.core.StandardHost</strong>) makes these additional attributes available:</p>


	<ul>
	<li><strong>deployXML</strong> (boolean=true): If set, context.xml files inside deployed applications (in /META-INF/) are used to define the Context for the application. If false, the administrator will have to provide a default external context configuration file in <span class="caps">TOMCAT</span>_HOME/conf/[enginename]/[hostname]/.</li>
		<li><strong>errorReportValveClass</strong> (string=&#8221;org.apache.catalina.valves.ErrorReportValve&#8221;): The default error reporting valve for this class, used to output error reports. You can supply a different class if you want to customise how error reporting is formatted.</li>
		<li><strong>unpackWARs</strong> (boolean=true): If true, any deployed <span class="caps">WAR</span> files are unpacked when deployed.</li>
		<li><strong>workDir</strong> (string=&#8221;TOMCAT_HOME/work/&lt;Engine&gt;/&lt;Host&gt;/&lt;Path&gt;/&#8221;): Path to the &#8220;scratch&#8221; directory for this Host, where compiled JSPs and other temporary files are put. If a workDir is set on a Context, it overrides this value.</li>
	</ul>


	<h3>Alias</h3>


	<p>You can nest an &lt;Alias&gt; element inside a Host element to set up an alias for the host, e.g.</p>


<pre class="ed">
&lt;Host name="example.com"&gt;
  &lt;Alias&gt;www.example.com&lt;/Alias&gt;
&lt;/Host&gt;
</pre>

	<h2>Realm</h2>


	<p>A Realm defines a role-based authentication and authorisation system (roles and users associated with those roles) for a Tomcat container. When a user attempts to use a resource protected by a Realm definition, Tomcat will request their credentials and compare them with some back-end &#8220;user database&#8221;. The simple example provided with a vanilla Tomcat install uses an <span class="caps">XML</span> file as this database; an alternative might be to use an <span class="caps">LDAP</span> directory or a database.</p>


	<p>A Realm can be associated with an <strong>Engine</strong>, <strong>Host</strong>, or <strong>Context</strong>: if you define a Realm for an Engine, it applies to all of that Engine&#8217;s Host elements; or if you define a Realm for a Host, it applies to all of its child Context elements.</p>


	<p>Attributes of a Realm element:</p>


	<ul>
	<li><strong>className</strong> (string): Java class name of the implementation to use. An instance of this class is used to do username and password lookups and determine the roles associated with a logged-in user. This class must implement the <strong>org.apache.catalina.Realm</strong> interface.</li>
	</ul>


	<p>Here are some of the available Realm implementations included as standard:</p>


	<ul>
	<li><strong><span class="caps">JDBC</span> Database Realm (className=org.apache.catalina.realm.JDBCRealm)</strong>: Uses a relational database accessible through <span class="caps">JDBC</span> (i.e. most databases) as the user database.</li>
		<li><strong>DataSource Database Realm (className=org.apache.catalina.realm.DataSourceRealm)</strong>: Uses a relational database as the back-end user database, but the connection is defined via <span class="caps">JNDI</span>.</li>
		<li><strong><span class="caps">JNDI</span> Directory Realm (className=org.apache.catalina.realm.JNDIRealm)</strong>: Uses an <span class="caps">LDAP</span> directory as the user database.</li>
		<li><strong>Memory Based Realm (org.apache.catalina.realm.MemoryRealm)</strong>: This is a simple (not-for-production) Realm which uses an <span class="caps">XML</span> file as the user database. It is not practical for production as you have to restart the server to add new users (the above options update dynamically as the back-end store changes).</li>
	</ul>


	<h2>Context</h2>


	<p>Each Context element represents a web application running inside a Host. The Context defines a variety of parameters specific to the application, for example:</p>


	<ul>
	<li>The path the Context is applicable to</li>
		<li>Whether the context uses cookies</li>
		<li>If static content can be cached</li>
		<li>Any resources needed by the application (including references to resources defined in the <strong>GlobalNamingResources</strong>)</li>
		<li>Valves for request processing</li>
		<li>The Realm used to authenticate and authorise this applcation</li>
		<li>Listeners for responding to lifecycle events</li>
	</ul>


	<p>Each application must have its own Context element defined; if none is defined, a default Context is used for that application, by using one of the configuration files described below.</p>


	<p>Contexts can be defined in several places:</p>


	<ul>
	<li><strong><span class="caps">META</span>-INF/context.xml</strong> (inside an individual web application): This is easiest for developers, as it means they can control their application&#8217;s Context outside of the Tomcat configuration. Note that if you define the Context in this file, but there is also a Context file in the Engine/Host configuration directory for this application (next bullet point), the Engine/Host/&lt;app&gt;.xml configuration takes precedence.</li>
		<li><strong><span class="caps">TOMCAT</span>_HOME/conf/&lt;Engine&gt;/&lt;Host&gt;/&lt;application&gt;.xml</strong>: This defines a Context specifically for the application at path <strong>/application</strong>. For example, an application available at the path /trivial in the jelica.com Host inside the JelicaEngine Engine could have its Context defined in a file called <strong><span class="caps">TOMCAT</span>_HOME/conf/JelicaEngine/jelica.com/trivial.xml</strong>. This file takes precedence over any <span class="caps">META</span>-INF/context.xml file defined for the application, if it exists.</li>
		<li><strong><span class="caps">TOMCAT</span>_HOME/conf/&lt;Engine&gt;/&lt;Host&gt;/context.xml.default</strong>: This Context will be loaded for all applications running inside the specified Engine and Host.</li>
		<li><strong><span class="caps">TOMCAT</span>_HOME/conf/context.xml</strong>: This file is loaded for all web applications. In the absence of a context.xml file which is more specific, just this file is used.</li>
	</ul>


	<p>Each Host requires a Context for its <strong><span class="caps">ROOT</span></strong> application, which corresponds to the empty path (/). This Context is used when no path is supplied and defines the &#8220;default&#8221; application for the Host. I cover how to set this up later when discussing virtual hosts.</p>


	<p>Attributes which can be defined for all Contexts:</p>


	<ul>
	<li><strong>docBase</strong> (string): Document Base, aka the Context Root. The directory containing the web application, or the <span class="caps">WAR</span> file containing the application. Absolute pathname, or relative to the <strong>appBase</strong> attribute of the Host container around this Context.</li>
		<li><strong>path</strong> (string): If the beginning of a request <span class="caps">URI</span> matches this path, this Context will be selected as the one to process the request. If you specify the empty string (&#8221;&#8221;), this Context will be the default application and will process any request not assigned to another Context inside this host. This attribute is derived from the directory name of the application by Tomcat, and need not be explicitly set. The special directory name <strong><span class="caps">ROOT</span></strong> should be used for the default web application for the Host.</li>
		<li><strong>className</strong> (string=org.apache.catalina.core.StandardContext): Java class name of the implementation of the <strong>org.apache.catalina.Context</strong> to use.</li>
		<li><strong>cookies</strong> (boolean=true): Whether to use cookies to identify client sessions. If false, <span class="caps">URL</span>-rewriting is relied on instead.</li>
		<li><strong>crossContext</strong> (boolean=false): If true, the application can get references to request dispatchers for other web applications inside this Host (less secure than the default).</li>
		<li><strong>override</strong> (boolean=false): Set to true to allow overriding of attributes defined in the DefaultContext element for this Host.</li>
		<li><strong>privileged</strong> (boolean=false): Set to true to allow this context to use container servlets, like the manager servlet. We use this attribute later to enable use of the Manager application by multiple virtual hosts.</li>
		<li><strong>backgroundProcessorDelay</strong> (int=-1): See previous explanations of backgroundProcess. If set to -1, this Context relies on its parent Host element for background processing.</li>
		<li><strong>reloadable</strong> (boolean=false): Set to true to have the classes and libraries in the web application monitored for changes. When a change is detected, the Context will reload the web application. Useful during development, as it makes changes immediately visible. Not recommended for production as it produces overhead. An alternative is to reload via the Manager, which can be done in production.</li>
		<li><strong>wrapperClass</strong> (string=org.apache.catalina.core.StandardWrapper): Java class name of the implementation of <strong>org.apache.catalina.Wrapper</strong> to be used for servlets managed by this Context. (The wrapper loads the servlets and manages their interaction with requests.)</li>
	</ul>


	<p>The standard Context implementation <strong>org.apache.catalina.core.StandardContext</strong> also exposes the following attributes:</p>


	<ul>
	<li><strong>allowLinking</strong> (boolean=false): Set to true to enable symlinking from inside the web application to resources outside its base directory. <span class="caps">DO NOT</span> set to true on Windows.</li>
		<li><strong>antiJARLocking</strong> (boolean=false): If true, Tomcat will attempt to sidestep problems that can occur if <span class="caps">JAR</span> files are locked (e.g. by another application outside the web application).</li>
		<li><strong>antiResourceLocking</strong> (boolean=false): Set to true to prevent file locking when applications startup. Slows application startup time, but means you can hot deploy and undeploy on platforms where file locking can occur. However, it also prevents <span class="caps">JSP</span> reloading on a running server due to a bug (at the moment).</li>
		<li><strong>cacheMaxSize</strong> (int=10240): Size in bytes of the static resource cache (default is 10Mb). Set higher if you want to do a lot of caching of large files.</li>
		<li><strong>cacheTTL</strong> (int=5000): Time in milliseconds between revalidation of cache entries (i.e. checking to see whether they are stale or not).</li>
		<li><strong>cachingAllowed</strong> (boolean=true): Set to false to disable caching of static resources. Note that if you have a lot of static content, it may be better to serve this via Apache or other web server, and just pass processing of dynamic content to Tomcat.</li>
		<li><strong>caseSensitive</strong> (boolean=true): Set to false (unintuitively) to disable case sensitivity checks. <span class="caps">DO NOT</span> set on Windows.</li>
		<li><strong>processTlds</strong> (boolean=true): Process Tag Library definitions. This can be set to false for applications which do not use tag libraries (e.g. servlet-only applications).</li>
		<li><strong>swallowOutput</strong> (boolean=false): Direct system output and error messages generated by the application (through System.out and System.err) to the application&#8217;s logger.</li>
		<li><strong>tldNamespaceAware</strong> (boolean=false): Validation of tag library definitions is namespace-aware (need tldValidation=&#8221;true&#8221; for this to be meaningful &#8211; see next bullet point). Performance penalty, but makes validation more strict.</li>
		<li><strong>tldValidation</strong> (boolean=false): Validate tag library definitions when the Context is started. Performance penalty if true, but could prevent problems caused by invalid tag libraries.</li>
		<li><strong>unloadDelay</strong> (int=2000): Length of time in milliseconds that the container will wait for servlets to unload.</li>
		<li><strong>unpackWAR</strong> (boolean=true): If true, all .war files in the webapps directory are unapcked before the application is available.    </li>
		<li><strong>useNaming</strong> (boolean=true): If true, a <span class="caps">JNDI</span> InitialContext for the web application is enabled when the Context is started.</li>
		<li><strong>workDir</strong> (string=&#8221;TOMCAT_HOME/work/&lt;EngineName&gt;/&lt;HostName&gt;/&lt;path&gt;&#8221;): Pathname to the scratch directory for the Context (accessible to servlets via the <strong>javax.servlet.context.tempdir</strong> attribute).</li>
	</ul>


	<h2>Valve</h2>


	<p>A Valve represents a component which can perform additional processing on requests before they are handled by the container. They can be applied to <strong>Engine</strong>, <strong>Host</strong> or <strong>Context</strong> elements.</p>


	<p>The attributes for a Valve depend on the Valve implementation. The only attribute they all share is:</p>


	<ul>
	<li><strong>className:</strong> The class name of the Java class implementing the Valve.</li>
	</ul>


	<p>The uses to which Valves can be put (in the default Tomcat install) are:</p>


	<ul>
	<li><strong>Access logging:</strong> Record requests processed by a container in standard log formats; similar to and compatible with Apache access logs. This is covered later.</li>
		<li><strong>Request filtering:</strong> Controlling access to a container by IP address and/or host name. This is covered later.</li>
		<li><strong>Request dumping:</strong> By using a Valve with className <strong>org.apache.catalina.valves.RequestDumperValve</strong>, you can dump all client requests to the log (including querystrings, cookies and headers). Useful for debugging.</li>
		<li><strong>Single sign-on:</strong> By assigning a single sign-on Valve (className = <strong>org.apache.catalina.authenticator.SingleSignOn</strong>) to a Host element, a client can login to one of the applications (Contexts) on that host to gain access to all protected applications. This uses cookie-based authentication behind the scenes.</li>
	</ul>


	<h1>The Manager tool</h1>


	<p>The Manager tool provides an overview of the applications running on the server. It enables you to enable, disable, undeploy or reload existing applications; and install new applications by uploading a .war file (see earlier).</p>


	<p>Both a <strong>web interface</strong> and a <strong><span class="caps">REST</span> interface</strong> are available (at http://localhost:8080/manager/html and http://localhost:8080/manager, respectively, in our case). You can also programmatically interact with Tomcat through <strong>Ant tasks</strong>, which enable deployment, reloading, undeploying, stopping and starting applications.</p>


	<p>Before you can use the Manager tool, you need to setup some user permissions. The basic authentication method is based on an <span class="caps">XML</span> file stored in <span class="caps">TOMCAT</span>_HOME/conf/tomcat-users.xml. Edit this file so it looks like this:</p>


<pre class="ed">
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;tomcat-users&gt;
  &lt;role rolename="admin"/&gt;
  &lt;role rolename="manager"/&gt;
  &lt;user username="elliot" password="police73" roles="manager,admin"/&gt;
&lt;/tomcat-users&gt;
</pre>

	<p>Restart Tomcat so your changes take effect. Now login to the manager application at http://localhost/manager. Enter your username and password when prompted. You should see something like this:</p>


	<p><img src="tomcat-manager.png" alt="" /></p>


	<p>Sections in the interface:</p>


	<ul>
	<li><strong>List Applications:</strong> Show all applications deployed to the server; start, stop, undeploy, reload individual applications. Form at the bottom of the page enables deployment.</li>
		<li><strong><span class="caps">HTML</span> Manager Help:</strong> Explains how to use the web interface to the Manager.</li>
		<li><strong>Manager Help:</strong> Explains how to use the <span class="caps">REST</span>-style Manager (via URLs).</li>
		<li><strong>Server Status:</strong> Gives a brief overview of the Tomcat server, operating system, <span class="caps">JVM</span> and Connectors. A bit hidden on this page is the <strong>Complete Server Status</strong> link, which will give exhaustive information about all the deployed applications.</li>
	</ul>


	<h2>Creating a really simple test application</h2>


	<p>It&#8217;s useful to have something to deploy and test when installing Tomcat. Here are some instructions for writing a <em>really</em> trivial web application to test the server and to test web application deployment.</p>


<ol>
<li>
mkdir -p trivial/WEB-INF/
</li>
<li>
Create a file <strong>trivial/WEB-INF/web.xml</strong> and put this into it:
<pre class="ed">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
      http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" 
    version="2.4"&gt;
&lt;/web-app&gt;
</pre>
</li>
<li>
Create a file <strong>trivial/index.jsp</strong> with this content:
<pre class="ed">
&lt;%
out.write("Hello trivial");
%&gt;
</pre>
</li>
<li>
Turn into a <span class="caps">WAR</span> file:
<pre class="cmd">
zip -r trivial.war trivial/*
</pre>
</li>
<li>
Drop the <span class="caps">WAR</span> file into the webapps directory (<strong>/opt/tomcat/webapps</strong>); Tomcat should auto-deploy it. An alternative approach is just to copy an unpacked directory into the webapps directory, rather than a <span class="caps">WAR</span> file.
</li>
<li>
Test it at <strong>http://localhost:8080/trivial/</strong>. You should get the content of index.jsp.
</li>
</ol>

	<p>N.B. you can setup a list of &#8220;welcome pages&#8221; for a Tomcat application, as you can in Apache, by adding an entry to the web.xml file for your application, e.g.</p>


<pre class="ed">
&lt;welcome-file-list&gt;
  &lt;welcome-file&gt;test.jsp&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;
</pre>

	<h2>Deploying applications to Tomcat using the Manager</h2>


	<p>One method of deploying an application to a Tomcat Host is by dropping the <span class="caps">WAR</span> file (or directory) containing the application into the webapps directory for that Host (as defined by the <strong>appBase</strong> attribute). This is the approach taken in the previous section.</p>


	<p>However, this is not great if you want to programmatically or conveniently deploy applications. In these cases, the Manager application can be useful. Here&#8217;s how to deploy our <strong>trivial</strong> application using the web interface.</p>


<ol>
<li>
We need to remove the existing <strong>trivial</strong> application, using the Manager application. You can then move the application and its <span class="caps">WAR</span> file from the webapps directory.
</li>
<li>
Fire up the Manager app. for localhost and login.
</li>
<li>
Scroll to the bottom of the main Manager page, to the <strong>Deploy</strong> section. We are going to use the second form in this section, <strong><span class="caps">WAR</span> file to deploy</strong>.
</li>
<li>
Click on the <strong>Browse</strong> button, and browse to the file on the local machine.
</li>
<li>
Click on <strong>Deploy</strong>. You should see something like this:<br/>
<br/>
<img src="deployed_trivial.png" alt="" />
</li>
</ol>

	<h3>The <span class="caps">REST</span> interface</h3>


	<p>As well as a <span class="caps">GUI</span> web interface, you can also interact with the Manager through a <span class="caps">REST</span> style (URL-based) interface. You can perform all of the tasks available through the <span class="caps">GUI</span> using the web interface.</p>


	<p>We&#8217;re not going to cover this, but it is well-documented in the installed Tomcat documentation at http://localhost:8080/manager/manager-howto.html.</p>


	<h3>Ant integration</h3>


	<p>It is also possible to use the Ant build tool (http://ant.apache.org/) to run Tomcat tasks. This can be useful for developers who need to frequently redeploy their applications to a Tomcat test server from inside an <span class="caps">IDE</span>. The Ant libraries for Tomcat-related tasks are available as part of the standard install at <strong><span class="caps">TOMCAT</span>_HOME/server/lib/catalina-ant.jar</strong>: developers wanting to use the tasks will need this <span class="caps">JAR</span> file.</p>


	<p>The tasks available include:</p>


	<ul>
	<li>Deploy/undeploy an application</li>
		<li>Start/stop a deployed application</li>
		<li>List applications</li>
		<li>Get the Tomcat server status</li>
	</ul>


	<p>This article &#8211; http://davidwinter.me.uk/articles/2006/03/21/using-tomcat-ant-tasks &#8211; describes how to use Ant for deploying and undeploying applications.</p>


	<h1>Recipes</h1>


	<p>Tomcat is very flexible, and supports a wide range of configurations, which makes exhaustive documentation of the possibilities difficult. However, below are some examples of typical tasks you may want to perform with your Tomcat installation.</p>


	<h2>Setting up a virtual host</h2>


	<p>Let&#8217;s say we want to setup a separate virtual host &#8220;jelica.com&#8221; (aliased to &#8220;www.jelica.com&#8221;) with its own application directory.</p>


<ol>
<li>
Make the directory to hold webapps for this host:
<pre class="cmd">
mkdir /opt/tomcat/jelica.com/webapps
chown tomcat.tomcat /opt/tomcat/jelica.com/webapps
</pre>
</li>
<li>
Put a webapp into a folder called <span class="caps">ROOT</span> inside the host&#8217;s webapp folder (we can use our demo app. for this). This is a specially-named application which will be used for the empty path (/) and act as the default application for the Host.
</li>
<li>
Add an entry inside the Engine section of conf/server.xml to define the host:
<pre class="ed">
&lt;Host appBase="jelica.com/webapps" name="jelica.com"&gt;
  &lt;Alias&gt;www.jelica.com&lt;/Alias&gt;
&lt;/Host&gt;
</pre>
</li>
<li>
Create the directory to hold the Context entry for this Host. It should go inside the <strong>conf/&lt;Engine&gt;/&lt;Host&gt;</strong> directory:
<pre class="cmd">
mkdir /opt/tomcat/conf/Catalina/jelica.com
chown tomcat.tomcat /opt/tomcat/conf/Catalina/jelica.com
</pre>
</li>
<li>
Create the Context entry for this host in <strong>/opt/tomcat/conf/Catalina/jelica.com/ROOT.xml</strong>:
<pre class="ed">
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;Context/&gt;
</pre>
Note that this isn&#8217;t strictly necessary, as Tomcat will auto-associate the <span class="caps">ROOT</span> folder inside the virtual host&#8217;s directory with the correct Context path. However, we&#8217;re placing it here for completeness, to demonstrate how to define the context for the <span class="caps">ROOT</span> application. We could now add extra elements inside the Context, e.g. to define a Realm or Valves for it.
</li>
<li>
Add an entry to <strong>/etc/hosts</strong> on the client machine so we can reach this domain:
<pre class="ed">
127.0.0.1  jelica.com www.jelica.com
</pre>
If you were doing this with a Windows client, you would need to make similar arrangements so the name can resolve. If you are using real domains you don&#8217;t need to do this, of course.
</li>
<li>Restart Tomcat</li>
<li>Test at <strong>http://jelica.com:8080/</strong>.</li>
</ol>

	<h2>Adding an access log to a Host</h2>


	<p>We can apply a <strong>Valve</strong> to a virtual host to perform access logging for that host.</p>


<ol>
<li>
mkdir /opt/tomcat/jelica.com/logs
</li>
<li>
Edit <strong>/opt/tomcat/conf/server.xml</strong> so it looks like this:
<pre class="ed">
&lt;Host name="jelica.com" appBase="jelica.com/webapps"&gt;
  &lt;Valve className="org.apache.catalina.valves.FastCommonAccessLogValve" 
         prefix="access_log." suffix=".log" 
         directory="${catalina.base}/jelica.com/logs" pattern="combined"/&gt;
&lt;/Host&gt;
</pre>
</li>
</ol>

	<p>Using the &#8220;combined&#8221; pattern gives you long entries in your log which correspond to the <strong>Combined</strong> log format popularised by Apache (http://httpd.apache.org/docs/2.2/logs.html#combined), e.g.</p>


	<p>127.0.0.1 &#8211; - [13/Aug/2006:19:36:34 +0100] &#8220;GET / <span class="caps">HTTP</span>/1.1&#8221; 304 &#8211; &#8221;-&#8221; &#8220;Mozilla/5.0 (X11; U; Linux i686; en-GB; rv:1.8.0.3) Gecko/20060523 Ubuntu/dapper Firefox/1.5.0.3&#8221;</p>


	<p>Note that the <strong>org.apache.catalina.valves.FastCommonAccessLogValve</strong> is recommended for production, but only supports the <strong>common</strong> (like &#8220;combined&#8221;, but without referrers or user agents) and <strong>combined</strong> log formats. If you want a more customisable log format, you&#8217;ll need to use the <strong>org.apache.catalina.valves.AccessLogValve</strong> class instead.</p>


	<p>Valve elements can be added to Engine elements, if you want to perform access logging for a whole Engine; or if you want to log individual Contexts (i.e. individual deployed applications), you can apply logs at that level too.</p>


	<h2>Giving a virtual host its own Manager application</h2>


	<p>It might be useful to give virtual host administrators their own Manager application, so they are able to deploy their own applications.</p>


<ol>
<li>
Create the file <strong>/opt/tomcat/conf/Catalina/jelica.com/manager.xml</strong> with this content:
<pre class="ed">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Context docBase="${catalina.base}/server/webapps/manager" privileged="true"&gt;
  &lt;Realm className="org.apache.catalina.realm.MemoryRealm" 
  pathname="${catalina.base}/jelica.com/users.xml"/&gt;
&lt;/Context&gt;
</pre>
Note that this specifies a type of Realm to use, and the path to the user database (XML file).
</li>
<li>
Create a new user database in <strong>/opt/tomcat/jelica.com/users.xml</strong> with this content:
<pre class="ed">
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;tomcat-users&gt;
  &lt;role rolename="manager"/&gt;
  &lt;user username="jelicauser" password="police73" roles="manager"/&gt;
&lt;/tomcat-users&gt;
</pre>
Note the manager application requires a user to have the <strong>manager</strong> role before they are given access. This can be modified by editing the <strong>web.xml</strong> file for the manager application itself. Note, however, that because we are associating a Realm with a context, only the <strong>/manager</strong> Context for this particular Host and Engine can be accessed by users in this database.
</li>
<li>Restart Tomcat</li>
<li>Access it at <strong>http://jelica.com:8080/manager/html</strong></li>
<li>Login with <em>jelicauser/police73</em></li>
</ol>

	<h2>Host-based access control</h2>


	<p>Valves can also be used to apply access control to an Engine, Host or Context element by either the requesting client&#8217;s host name or IP address. This could be used to limit the availability of intranet applications, or to deny access to troublesome clients.</p>


	<p>For both types of Valve, the following attributes can be defined:</p>


	<ul>
	<li><strong>className</strong>: Java class name of the implementation to use.
	<ul>
	<li>For restriction by host name: <strong>org.apache.catalina.valves.RemoteHostValve</strong></li>
		<li>For restriction by host IP address: <strong>org.apache.catalina.valves.RemoteAddrValve</strong></li>
	</ul>
	</li>
		<li><strong>allow</strong>: A comma-separated list of regular expression patterns that the remote client&#8217;s IP address or host name is compared to. For a client request to be accepted, the client&#8217;s host name or IP address (depending on the class of Valve) <em><span class="caps">MUST</span></em> match one of these patterns. If not specified, all requests are accepted <em><span class="caps">EXCEPT</span></em> those which satisfy the criteria of the <strong>deny</strong> attribute (see below).
	<ul>
	<li><strong>deny</strong>: A comma-separated list of regular expression patterns that the remote client&#8217;s host name or IP address is compared to. For a client request to be accepted, the client&#8217;s host name or IP address (depending on the class of valve) <em><span class="caps">MUST NOT</span></em> match any of these patterns. If no pattern is given, no clients are denied.</li>
	</ul></li>
	</ul>


	<h3>Example access restriction setup</h3>


	<p>Here&#8217;s an example of how to restrict access to an application by subnet and host name. As an example, we might have an application <strong>/manager</strong> running on a machine with IP address 10.0.2.10. We want:</p>


	<ul>
	<li>Only the local machine to be able to access the /manager application</li>
		<li>Other machines on this network to be able to access other applications on the machine (but not the manager application)</li>
		<li>Any machines off this network to be denied access to applications on this Tomcat server</li>
	</ul>


	<p>To do this, we have to:</p>


<ol>
<li>Define a Valve on the /manager Context, e.g in <strong>/opt/tomcat/conf/Catalina/localhost/manager.xml</strong>:
<pre class="ed">
&lt;Valve className="org.apache.catalina.valves.RemoteHostValve" allow="localhost"/&gt;
</pre>
This implicitly denies access to any machine other than localhost. Note that for this to work, the Connector associated with the Context must have <strong>enableLookups</strong> set to true, e.g.
<pre class="ed">
&lt;Connector port="8080" enableLookups="true" 
  minSpareThreads="25" maxThreads="150" 
  maxSpareThreads="75" connectionTimeout="20000"/&gt;
</pre>
</li>
<li>Define a Valve on the Engine (as this processes all requests for a Service) in /opt/tomcat/conf/server.xml:
<pre class="ed">
&lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" 
allow="10.0.2.*"/&gt;
</pre>
If you want to specify multiple regular expressions, separate them with commas, e.g.
<pre class="ed">
&lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" 
allow="10.0.2.*,192.168.13.*"/&gt;
</pre>
</li>
</ol>

	<p>The final manager.xml file should look like this:</p>


<pre class="ed">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Context docBase="${catalina.base}/server/webapps/manager" privileged="true"&gt;
  &lt;Valve className="org.apache.catalina.valves.RemoteHostValve" allow="localhost"/&gt;
  &lt;Realm className="org.apache.catalina.realm.MemoryRealm" 
    pathname="${catalina.base}/jelica.com/users.xml"/&gt;
&lt;/Context&gt;
</pre>

	<p>You should now:</p>


	<ul>
	<li>Be able to login to the manager application from the local machine.</li>
		<li>Be able to access the default web application from other machines on the 10.0.2 subnet (but not the Manager).</li>
		<li>Not be able to access any applications on the machine from anywhere else.</li>
	</ul>


	<h2>Logging a virtual host</h2>


	<p>Tomcat uses the standard Java logging infrastructure (by default) to perform logging. It also automatically sets up logging for localhost applications, as well as generic logging for the whole server. However, if you add your own virtual hosts or applications, you may want to separate out the logging for those components into dedicated files. (It turns out this is a bit painful, but bear with me.)</p>


	<p>Here&#8217;s how we can add logging for the virtual host we set up in the previous section:</p>


<ol>
<li>
Edit <strong>/opt/tomcat/conf/logging.properties</strong> and add a new entry to the handlers definition at the top of the file:
<pre class="ed">
handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler,
3manager.org.apache.juli.FileHandler, 4admin.org.apache.juli.FileHandler, 5host-
manager.org.apache.juli.FileHandler, 6jelicacom.org.apache.juli.FileHandler, 
java.util.logging.ConsoleHandler
</pre>
Here I&#8217;ve defined a new handler called <strong>6jelicacom.org.apache.juli.FileHandler</strong>
</li>

<li>
Define the handler properties:
<pre class="ed">
6jelicacom.org.apache.juli.FileHandler.level = ALL
6jelicacom.org.apache.juli.FileHandler.directory = ${catalina.base}/logs
6jelicacom.org.apache.juli.FileHandler.prefix = jelicacom.
</pre>
</li>

<li>
Attach the default logger for the Host (as generated by Tomcat) to the new handler:
<pre class="ed">
org.apache.catalina.core.ContainerBase.[Catalina].[jelica.com].level = ALL
org.apache.catalina.core.ContainerBase.[Catalina].[jelica.com].handlers = \
   6jelicacom.org.apache.juli.FileHandler
</pre>

	<p>(Note that instead of defining a new handler, I could have attached logging for the Engine/Host/Context to an existing handler.)</p>


	<p>Default loggers are setup by Tomcat for each of the following components setup in <strong>server.xml</strong>:</p>


<ul>
<li>Each Engine gets a logger called<br/>
<strong>org.apache.catalina.core.ContainerBase.[&lt;EngineName&gt;]</strong><br/>
where &lt;EngineName&gt; is the name defined for the Engine.</li>
<li>Each Host (inside an Engine) gets a logger called:<br/>
<strong>org.apache.catalina.core.ContainerBase.[&lt;EngineName&gt;].[&lt;HostName&gt;]</strong><br/>
where &lt;HostName&gt; is the name defined for the Host.</li>
<li>Each Context (inside a Host, inside an Engine) gets a logger called:<br/>
<strong>org.apache.catalina.core.ContainerBase.[&lt;EngineName&gt;].[&lt;HostName&gt;].</strong><br/>
<strong lang="&lt;ContextPath&gt;">*, where &lt;ContextPath&gt; is the path for the Context, e.g. [/manager].</li>
</ul>

</li>

<li>Restart Tomcat</li>

<li>
Inside a <span class="caps">JSP</span> or servlet, you can call the *log</strong> method to write a message to the new custom log, e.g.
<pre class="ed">
log("Email sent to elliot@moochlabs.com");
</pre>
Add this in your index.jsp file
</li>
<li>Test at <strong>http://localhost:8080/trivial/</strong>.</li>
<li>Check /opt/tomcat/logs for a file called <strong>jelicacom.YYYY-MM-DD.log</strong>.</li>
</li>
</ol>

	<h2>Clearing the cache</h2>


	<p>When developing with Tomcat, it is continuously working in the background to recompile JSPs and also caching static content. However, with a rapidly-changing application, you may find that links on static <span class="caps">HTML</span> pages are turning stale (e.g. if content is moving around) or strange session errors start occuring. In this case, it can sometimes help to clear the cache for an application so you know you are starting from a clean slate.</p>


	<p>Each application which uses caching, compiles JSPs, or does other temporary work produces a work directory. This can be specified explicitly for the Context, but typically the default will be left. The work directory for our <strong>trivial</strong> application, inside the <strong>jelica.com</strong> Host, inside the <strong>JelicaEngine</strong> engine can be found in:</p>


<pre class="cmd">
/opt/tomcat/work/Catalina/jelica.com/trivial
</pre>

	<p>This contains compiled JSPs, as well as cached tag libraries and session storage. You can clear the cache for the application by simply (and carefully!) removing the content of this directory:</p>


<pre class="cmd">
rm -Rf /opt/tomcat/work/Catalina/jelica.com/trivial/*
</pre>

	<p>Note that it may seem like this hasn&#8217;t worked, but this is probably because the browser is also caching pages! To ensure the browser fetches a fresh copy of a page, use <strong>Ctrl+F5</strong> to do a &#8220;mighty refresh&#8221;.</p>


	<h2>Running two servers on different ports</h2>


	<p>You can deploy multiple Service elements from a single Tomcat instance, which enables you to completely isolate hosts from one another so there is no chance of cross-contamination. For example, you might want to give each client their own Tomcat Service over which they have administrative control.</p>


	<p>Here&#8217;s one example configuration for a new virtual host <strong>oceanarea.com</strong>:</p>


<ol>

<li>Create the directory and its webapps directory for the virtual host:

<pre class="cmd">
mkdir -p /opt/tomcat/oceanarea.com/webapps
</pre>
</li>

<li>
Configure the new Service in <strong>conf/server.xml</strong>:
<pre class="ed">
&lt;Service name="OceanareaService"&gt;
  &lt;Connector port="8090"/&gt;
  &lt;Engine name="OceanareaEngine" defaultHost="oceanarea.com"&gt;
    &lt;Host name="oceanarea.com" appBase="oceanarea.com/webapps"/&gt;
  &lt;/Engine&gt;
&lt;/Service&gt;
</pre>
</li>

<li>Create the required directories in <strong>conf</strong>:
<pre class="cmd">
cd /opt/tomcat/conf
mkdir -p OceanareaEngine/oceanarea.com
</pre>
Note for each virtual host, you need a directory called <strong>/opt/conf/&lt;Engine&gt;/&lt;Host&gt;/</strong>.
</li>

<li>Put the <span class="caps">ROOT</span> context descriptor into <strong>/opt/tomcat/conf/OceanareaEngine/oceanarea.com/ROOT.xml</strong>:
<pre class="ed">
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;Context/&gt;
</pre>
Note that our Context entry is currently empty: we don&#8217;t need to specify a path or docBase attribute, as these can be generated using the Tomcat defaults. However, we may want to add extra Context settings for the Host here. Alternatively, we could put a context.xml file in the <span class="caps">META</span>-INF directory for our application.
</li>

<li>Create the <span class="caps">ROOT</span> folder inside the webapps directory for our new Service (i.e. we&#8217;re aiming for a directory called <strong>/opt/tomcat/oceanarea.com/webapps/ROOT/</strong>). I suggest copying our test web application in there and editing index.jsp so we know we&#8217;re looking at the right Service.
</li>

<li>Restart Tomcat</li>

<li>Add another entry to /etc/hosts for the new host name:
<pre class="ed">
127.0.0.1  oceanarea.com
</pre>
</li>

<li>Test at <strong>http://oceanarea.com:8090/</strong></li>
</ol>

	<h1>The Administration tool</h1>


	<p>This tool provides a <span class="caps">GUI</span> interface to configuring the server.xml file. However, it does not cover some of the configuration options you may need to get the most control over the server.</p>


	<p>The tool used to be installed by default, but is no longer. You now need to do your own installation. We downloaded it right at the beginning of the course as a tarball. We can now install it like this:</p>


<ul>
<li>
Unpack the tarball:
<pre class="cmd">
tar zxvf apache-tomcat-5.5.17-admin.tar.gz -C /opt/apache-tomcat-5.5.17
</pre>
This puts the files into /opt/apache-tomcat-5.5.17; most of them end up in <strong>/opt/apache-tomcat-5.5.17/server/webapps/admin</strong>
</li>
<li>
Make tomcat the owner of the files:
<pre class="cmd">
chown -R tomcat.tomcat /opt/apache-tomcat-5.5.17
</pre>
</li>
</ul>

	<p>The permissions for the application are set up using the same tomcat-users.xml file as for the manager app.. Any users assigned the <strong>admin</strong> role in that file have access to this application.</p>


	<p>One of the most useful functions the Administration application provides is an overview of how your server is configured. I tend to use it this way but perform configuration tasks from the command line.</p>


	<h1>Advanced configuration</h1>


	<p>Tomcat can integrate with a variety of other servers and systems. The following sections mainly cover integration with other pieces of software.</p>


	<h2>MySQL integration</h2>


	<p>MySQL is a very common open source database server, and easy to get working with Tomcat. There is a <span class="caps">JDBC</span> (Java&#8217;s database connectivity standard) driver for MySQL called <strong>Connector/J</strong> which you can make available to any applications running on the server.</p>


	<h3>Basic MySQL setup</h3>


<ol>
<li>Ensure MySQL is installed:
<pre class="cmd">
apt-get install mysql-server
</pre>
</li>
<li>Set a root password for the MySQL server:
<pre class="cmd">
mysql password police73
</pre>
</li>
<li>Login to MySQL via command line:
<pre class="cmd">
mysql -uroot -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 10 to server version: 5.0.21-Debian_3ubuntu1-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt;
</pre>
</li>
<li>
Create a database for the Java application:
<pre class="cmd">
mysql&gt; create database trivial;
Query OK, 1 row affected (0.13 sec)
</pre>
</li>
<li>
Create a table inside the database:
<pre class="cmd">
mysql&gt; CREATE TABLE people (id INT AUTO_INCREMENT, 
name VARCHAR(255), PRIMARY KEY (id));
</pre>
</li>
<li>
Add some data we can use for testing:
<pre class="cmd">
mysql&gt; INSERT INTO people(name) VALUES('Elliot Smith');
Query OK, 1 row affected (0.07 sec)

mysql&gt; INSERT INTO people(name) VALUES('Mickey Mouse');
Query OK, 1 row affected (0.00 sec)
</pre>
</li>
<li>
Create a user <strong>trivial</strong> with password <strong>police73</strong> for the Java application database:
<pre class="cmd">
mysql&gt; grant all privileges on trivial.* to trivial identified by 'police73';
Query OK, 0 rows affected (0.02 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)
</pre>
</li>
</ol>

	<h3>Using MySQL from a Java web application</h3>


<ol>
<li>Download the <span class="caps">JDBC</span> driver can be downloaded from: http://mysql.com/downloads/connector/j/5.0.html (version 5 is the current recommended release). Get the tarball release.</li>
<li>Unpack the tarball. We are only interested in one file inside the tarball, called <strong>mysql-connector-java-5.0.3-bin.jar</strong>: copy this to <strong>/opt/tomcat/common/lib</strong>.</li>
<li>Restart Tomcat</li>
<li>Add a file to your <strong>trivial</strong> application called <strong>mysqltest.jsp</strong> with this content:
<pre class="ed">
&lt;%@ page import="java.sql.*" %&gt;
&lt;%
// load the MySQL driver
Class.forName("com.mysql.jdbc.Driver").newInstance();

// get a connection
String url = "jdbc:mysql://localhost/trivial?user=trivial&#38;password=police73";
java.sql.Connection conn = DriverManager.getConnection(url);

// the SQL we're going to execute
String sql = "SELECT * FROM people";

// prepare and execute the SQL
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);

// loop through resultset
while (rs.next()) {
  out.write(rs.getString(1) + " " + rs.getString(2));
  out.write("&lt;br&gt;");
}

// release resources
stmt.close();
conn.close();
%&gt;
</pre>

	<p><span class="alert">Note: this is not the way you should write your MySQL connection code! It should be in a servlet at the very least. This is just for testing purposes.</span></p>


</li>
<li>
Test in the browser at <strong>http://localhost:8080/trivial/testmysql.jsp</strong>.
</li>
<li>
You should see something like this in the browser:<br/>
<br/>
<img src="mysql-test-result.png" alt="" />
</li>
</ol>

	<p>Once MySQL support is available in Tomcat, you can use MySQL as a database back-end for user authentication using a JDBCRealm implementation. There are good instructions on how to do this in the Tomcat documentation at: http://localhost:8080/tomcat-docs/realm-howto.html#JDBCRealm.</p>


	<h3><span class="caps">JDBC</span> Resources</h3>


	<p>It is possible to create a <span class="caps">JDBC</span> Datasource Resource element in the Context for an application. This provides a <span class="caps">JDBC</span> connection pool for the application, which can improve efficiency if there are large large numbers of connections to the database.</p>


	<p>Setting up a Datasource for a single Context requires the following steps:</p>


<ol>
<li>
Add a Resource element to the Context for the <strong>trivial</strong> application by editing <strong>/opt/tomcat/conf/Catalina/jelica.com/trivial.xml</strong> so it looks like this:
<pre class="ed">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Context&gt;
  &lt;Resource name="jdbc/people" auth="Container" 
  type="javax.sql.DataSource" username="trivial" password="police73" 
  driverClassName="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/trivial" 
  maxActive="24" maxIdle="4"/&gt;
&lt;/Context&gt;
</pre>
</li>

<li>Add a file to your <strong>trivial</strong> application called <strong>mysqltest2.jsp</strong> with this content:
<pre class="ed">
&lt;%@ page import="java.sql.*, javax.sql.*, javax.naming.*" %&gt;
&lt;%
// get the connection from the pool via a Resource defined for this Context
Context initCtx = new InitialContext();
DataSource ds = (DataSource)initCtx.lookup("java:comp/env/jdbc/people");
Connection conn = ds.getConnection();

// the SQL we're going to execute
String sql = "SELECT * FROM people";

// prepare and execute the SQL
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);

// loop through resultset
while (rs.next()) {
  out.write(rs.getString(1) + " " + rs.getString(2));
  out.write("&lt;br&gt;");
}

// release resources
stmt.close();
conn.close();
%&gt;
</pre>
</li>
</ol>

	<p>Alternatively, you can create a Resource inside the <strong>GlobalNamingResources</strong> element which is globally available across the server and linked to individual Context elements using the ResourceLink element. If the Resource is defined in <strong>GlobalNamingResources</strong> (i.e. if we moved the whole &lt;Resource&gt; element into the &lt;GlobalNamingResources&gt; element), we would need to add a <strong>ResourceLink</strong> element to the Context for the application (in <strong>/opt/tomcat/conf/Catalina/jelica.com/trivial.xml</strong>):</p>


<pre class="ed">
&lt;ResourceLink global="jdbc/people" name="jdbc/people" type="javax.sql.DataSource"/&gt;
</pre>

	<p>Note that the <strong>global</strong> attribute refers to the <span class="caps">JNDI</span> name for the resource in the global resource namespace; while the <strong>name</strong> attribute is how the resource can be referenced within the application.</p>


	<p>See the next section for an example of doing this in the context of creating global mail sessions.</p>


	<h2>Enabling email out of applications</h2>


<ol>
<li>Install postfix:<br/>
<pre class="cmd">
apt-get install postfix mailutils
</pre>
Set as internet site<br/>
Set mail name to openadvantage.org<br/>
</li>
<li>
Test mail setup using mailutils:
<pre class="cmd">
echo 'hello world' | mail -s 'test from postfix' elliot@moochlabs.com
</pre>
</li>
<li>Download JavaMail from: http://java.sun.com/products/javamail/downloads/index.html</li>
<li>Download <span class="caps">JAF</span> (Java Activation Framework) from: http://java.sun.com/products/javabeans/jaf/downloads/index.html</li>
<li>Unzip <span class="caps">JAF</span> and JavaMail and drop the enclosed .jar files into the <strong>/opt/tomcat/common/lib/</strong> directory:
<pre class="cmd">
unzip jaf-1_1-fr.zip
cp jaf-1.1/activation.jar /opt/tomcat/common/lib/
unzip javamail-1_4.zip
cp javamail-1.4/cp mail.jar /opt/tomcat/common/lib/
chown -R tomcat.tomcat /opt/tomcat/common/lib/
</pre>
</li>
<li>Add this element inside <strong>GlobalNamingResources</strong> in server.xml:
<pre class="ed">
&lt;Resource name="mail/session" type="javax.mail.Session" mail.smtp.host="localhost" 
auth="Container"/&gt;
</pre>
Note that the name for the Resource should start with &#8220;mail/&#8221;.
</li>
</ol>

	<p>If this hasn&#8217;t worked, your Tomcat server may not start at all, and you&#8217;ll get something that looks like this in catalina.out:</p>


<pre class="cmd" style="font-size:90%;">
java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:294)
        at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:432)
Caused by: java.lang.NoClassDefFoundError: javax/mail/Authenticator
        at org.apache.naming.factory.MailSessionFactory.getObjectInstance(MailSessionFactory.java:104)
        at org.apache.naming.factory.ResourceFactory.getObjectInstance(ResourceFactory.java:139)
</pre>

	<p>If it worked, you shouldn&#8217;t get any errors in catalina.out.</p>


	<p>To test whether Tomcat has access to the mail session:</p>


<ol>
<li>
Associate your web application with this session by adding this to the web.xml file for the <strong>trivial</strong> application (in /opt/tomcat/webapps/trivial/WEB-INF/web.xml):

<pre class="ed">
&lt;resource-ref&gt;
  &lt;description&gt;
    Resource reference for mail session
  &lt;/description&gt;
  &lt;res-ref-name&gt;
    mail/session
  &lt;/res-ref-name&gt;
  &lt;res-type&gt;
    javax.mail.Session
  &lt;/res-type&gt;
  &lt;res-auth&gt;
    Container
  &lt;/res-auth&gt;
&lt;/resource-ref&gt;
</pre>

	<p>Note that this approach doesn&#8217;t seem to work for <span class="caps">JDBC</span> DataSources: the ResourceLink approach (described in the section of <span class="caps">JDBC</span> Resources) is the only one which seems to work properly.</p>


	<p>We could also use a ResourceLink for the resource in the context for the web application (e.g. in <strong>/opt/tomcat/conf/Catalina/jelica.com/trivial.xml</strong>). This would remove the need for the &lt;resource-ref&gt; element in the web.xml file for the app.:</p>


<pre class="ed">
&lt;ResourceLink global="mail/session" name="mail/session" type="javax.mail.Session"/&gt;
</pre>

</li>

<li>
Create a test <span class="caps">JSP</span> to send an email using this resource inside <span class="caps">TOMCAT</span>_HOME/webapps/trivial/testmail.jsp:

<pre class="ed">
&lt;%@ page import="javax.mail.*, javax.mail.internet.*, javax.naming.*" %&gt;
&lt;%
Context initCtx = new InitialContext();
Context envCtx = (Context) initCtx.lookup("java:comp/env");
Session s = (Session) envCtx.lookup("mail/session");

MimeMessage message = new MimeMessage(s);

// need a real address here, preferably with a domain matching
// your postfix server's mail name
InternetAddress from = new InternetAddress("elliot@openadvantage.org");
message.setFrom(from);
// and a real address here
InternetAddress to = new InternetAddress("elliot@moochlabs.com");
message.addRecipient(Message.RecipientType.TO, to);

message.setSubject("Test from Tomcat via JavaMail session");
message.setText("Hello from mail initialised from JNDI resource setting");

Transport.send(message);
%&gt;
</pre>

	<p><span class="alert">This is <span class="caps">NOT</span> the way you should write applications to do this sort of thing. It&#8217;s just a quick and dirty way to test whether your mail setup works.</span>
</li></p>


<li>Test at <strong>http://localhost:8080/trivial/testmail.jsp</strong>.</li>
</ol>

	<h2>Tomcat and <span class="caps">APR</span></h2>


	<p>Tomcat can use the Apache Portable Runtime to make its performance closer to that of a dedicated web server (rather than a back-end application server). For example, this provides higher performance for serving static files and makes the server more scalable.</p>


	<p>Complete information at: http://tomcat.apache.org/tomcat-5.5-doc/apr.html</p>


	<p>By default this is not enabled and you have to install it yourself. You can tell it&#8217;s not enabled because you will get a line like this in catalina.out:</p>


<pre class="cmd">
INFO: The Apache Tomcat Native library which allows optimal performance 
in production environments was not found on the java.library.path: 
/opt/jdk1.5.0_07/jre/lib/i386/server:/opt/jdk1.5.0_07/jre/lib/i386:/opt/jdk1.5.0_07/jre/../lib/i386
</pre>

	<p>To enable on Ubuntu:</p>


<ol>
<li>
Install the libapr1.0 and OpenSSL libraries and development headers (you need the universe repository enabled to install libapr1.0):
<pre class="cmd">
apt-get install openssl openssl-dev libapr1.0-dev
</pre>
</li>
<li>
Unpack the source for the Tomcat <span class="caps">APR</span> wrappers:
<pre class="cmd">
cp /opt/tomcat/bin/tomcat-native.tar.gz /opt
cd /opt
tar zxvf tomcat-native.tar.gz
</pre>
</li>
<li>
Configure and make the wrappers:
<pre class="cmd">
cd tomcat-native-xxx/jni/native
./configure --prefix=/opt/tomcat-apr --with-apr=/usr/bin/apr-1-config \
--with-java-home=/opt/java
make
make install
</pre>
</li>
<li>
Symlink the libtcnative-1.so file into the Java library path, e.g.
<pre class="cmd">
ln -s /opt/tomcat-apr/lib/libtcnative-1.so /opt/java/jre/lib/i386/
</pre>
(If you prefer, you could set the --prefix directive to /opt/java/jre, which would put the contents of the lib directory into the /opt/java/jre directory and remove the need for the symlink)
</li>
</ol>

	<p>If all went well, when you restart Tomcat, you should no longer get the error message about the Apache Tomcat Native library being missing.</p>


	<h2>Enabling <span class="caps">SSL</span></h2>


	<p><span class="alert">If Tomcat is running without <span class="caps">APR</span>, SSL setup uses <span class="caps">JSSE</span> (Java Secure Socket Extension). The instructions below only apply for Tomcat running in standalone mode using <span class="caps">APR</span>. Also note that you can&#8217;t manage <span class="caps">APR SSL</span> Connectors in the Administrator application (though you can manage <span class="caps">JSSE</span> ones).</span></p>


	<p><span class="alert">Another approach is to put Apache in front of Tomcat and forward Apache <span class="caps">SSL</span> connections to Tomcat via mod_jk. This approach is covered at http://tomcat.apache.org/tomcat-3.2-doc/tomcat-ssl-howto.html#s5.</span></p>


	<p>What we&#8217;re going to do is setup Tomcat to run as a standalone <span class="caps">SSL</span> server over an <span class="caps">APR</span> connector.</p>


<ol>
<li>
Create an <span class="caps">SSL</span> certificate; you can do this using the openssl command, or cheat using this Apache command:

<pre class="cmd">
apache2-ssl-certificate
</pre>

	<p>Here&#8217;s what I entered at the prompts:</p>


<pre class="cmd">
Country Name (2 letter code) [GB]:
State or Province Name (full name) [Some-State]:West Midlands
Locality Name (eg, city) []:Birmingham
Organization Name (eg, company; recommended) []:mooch labs
Organizational Unit Name (eg, section) []:
server name (eg. ssl.domain.tld; required!!!) []:localhost
Email Address []:
</pre>

This generates a public and private key for your web server: we are going to use these for our Tomcat server.
</li>
<li>Copy the generated Apache public and private keys to your Tomcat instance. These reside in <strong>/etc/apache2/ssl</strong>.
<ul>
<li>The certificate file has a .pem suffix. Copy this to <strong>/opt/tomcat/conf/localhost.crt</strong>.</li>
<li>The private key file has a random-looking filename. Copy this to <strong>/opt/tomcat/conf/localhost.key</strong>.</li>
<li>chown both files to tomcat.tomcat.</li>
</ul>
</li>
<li>
Add the following element to server.xml inside the <strong><Service name="Catalina"></strong> element:

<pre class="ed">
&lt;Connector port="8443" maxHttpHeaderSize="8192" 
    maxThreads="150" minSpareThreads="25" maxSpareThreads="75" 
    enableLookups="false" disableUploadTimeout="true" 
    acceptCount="100" scheme="https" secure="true" 
    SSLEngine="on" 
    SSLCertificateFile="${catalina.base}/conf/localhost.crt" 
    SSLCertificateKeyFile="${catalina.base}/conf/localhost.key" /&gt;
</pre>
</li>
<li>
Test at <strong>https://localhost:8443/</strong>.
</li>
</ol>

	<h2>Proxying through Apache</h2>


	<p>Apache has a <strong>mod_proxy</strong> module which enables it to be treated as a proxy server, fronting requests for other back-end servers. You can use this feature to incorporate a Tomcat application into an otherwise Apache-hosted website by redirecting requests for particular paths to an application on the Tomcat server.</p>


	<p>Here&#8217;s an example scenario:</p>


	<ul>
	<li>We have a default Apache website at <strong>http://localhost/</strong>.</li>
		<li>Our Tomcat application is at <strong>http://localhost:8080/trivial</strong>.</li>
		<li>We want to map all requests to <strong>http://localhost/trivial</strong> (currently served by Apache) onto the Tomcat application.</li>
	</ul>


	<p>To setup the Apache website, we&#8217;ll use Ubuntu&#8217;s default Apache install:</p>


<ol>
<li>Ensure Apache is running:
<pre class="cmd">
/etc/init.d/apache2 start
</pre>
</li>
<li>Check at <strong>http://localhost/</strong>.</li>
</ol>

	<p>To configure Apache to serve as a proxy:</p>


<ol>
<li>
Load the proxy modules. I&#8217;m going to do this in a custom configuration file <strong>/etc/apache2/mods-available/proxy_custom.conf</strong> (Ubuntu provides default config. files for the proxy modules, but they are quite cluttered):

<pre class="ed">
LoadModule proxy_module /usr/lib/apache2/modules/mod_proxy.so
LoadModule proxy_module_http /usr/lib/apache2/modules/mod_proxy_http.so

ProxyRequests Off

&lt;Proxy *&gt;
Order deny,allow
Deny from all
Allow from 127.0.0.1
&lt;/Proxy&gt;

ProxyPass /trivial http://localhost:8080/trivial
ProxyPassReverse /trivial http://localhost:8080/trivial
</pre>
</li>

<li>
Symlink the config. file into sites-enabled:
<pre class="cmd">
ln -s /etc/apache2/sites-available/proxy_custom.conf /etc/apache2/sites-enabled/
</pre>
</li>
<li>Reload Apache</li>
</ol>

	<p>If you want to proxy a directory onto a host, this is also possible. You can use the same config. as above, but with the ProxyPass and ProxyPassReverse settings like so:</p>


<pre class="ed">
ProxyPass /trivial http://jelica.com:8090
ProxyPassReverse /trivial http://jelica.com:8090
</pre>

	<p>Note there are no trailing slashes on either the Apache path or the Tomcat application <span class="caps">URL</span>.</p>


	<h2>Proxying through mod_jk</h2>


	<p>An alternative to using <strong>mod_proxy</strong> is to make use of <strong>mod_jk</strong> instead. This is far more efficient, but slightly harder to configure. Unlike mod_proxy, which forwards <span class="caps">HTTP</span> requests to a Tomcat <span class="caps">HTTP</span> connector, mod_jk talks to a specialised connector on Tomcat. The Tomcat instance should be running an <span class="caps">AJP</span> connector to handle proxied requests: the <span class="caps">AJP</span> protocol is specifically designed to serve proxied requests, and streamlined for this purpose.</p>


<ol>
<li>Before you can start using mod_jk on Ubuntu, you need to install the Apache module:
<pre class="cmd">
apt-get install libapache2-mod-jk
</pre>
This also pulls the appropriate module loading directives into Apache.
</li>
<li>
Check it is available by going to <strong>http://localhost/</strong>. You should see something like this:

	<p><img src="server-sig.png" alt="" /></p>


Note the presence of <strong>mod_jk</strong> in the server signature line.
</li>
<li>
You then need to configure a Tomcat worker. A worker is basically a connector which exists to run servlets on behalf of a front-end web server (like Apache). The worker file defines how Apache can talk to the Tomcat worker, and is located in <strong>/etc/apache2/workers.properties</strong>:

<pre class="ed">
worker.list=worker1
worker.worker1.port=8009
worker.worker1.host=localhost
worker.worker1.type=ajp13
</pre>

We have only defined a single Tomcat worker here called <strong>worker1</strong>, but it is possible to configure Apache to talk to a cluster of Tomcat workers.
</li>
<li>
You then instruct Apache to talk to the worker by adding some configuration directives to Apache. We&#8217;ll do this in a file called <strong>/etc/apache2/mods-enabled/jk.conf</strong>:

<pre class="ed">
Alias /trivial /opt/tomcat/webapps/trivial
JkWorkersFile /etc/apache2/workers.properties
JkLogFile /var/log/apache2/mod_jk.log
JkLogLevel debug
JkMount /trivial/* worker1
&lt;LocationMatch /trivial/(WEB-INF|META-INF)&gt;
  Deny from all
  AllowOverride None
&lt;/LocationMatch&gt;
</pre>

Note this sets the log to debug level, which is not good for production, but is good for testing. Turn down to <strong>info</strong> in production. I&#8217;ve also defined a LocationMatch, which is not strictly necessary but gives a firm access denied message if either the <span class="caps">WEB</span>-INF or <span class="caps">META</span>-INF directory is requested.
</li>
<li>
Symlink jk.conf to enable it:

<pre class="cmd">
ln -s /etc/apache2/mods-available/jk.conf /etc/apache2/mods-enabled/
</pre>
</li>
<li>
Reload Apache
</li>
<li>
And then setup the Tomcat connector:

<pre class="ed">
&lt;Connector port="8009" protocol="AJP/1.3"/&gt;
</pre>
</li>
<li>
Test at <strong>http://localhost/trivial/</strong>.
</li>
</ol>

	<p>If you want to restrict access to an application so it is only available via the proxy, you could create a separate Service specifically for serving proxied applications over an <span class="caps">AJP</span> Connector.</p>


	<p>If you only want to proxy <span class="caps">JSP</span> or servlet requests to Tomcat, you could specify this in the <strong>JkMount</strong> directive explicitly, e.g.</p>


<pre class="ed">
JkMount /trivial/*.jsp worker1
JkMount /trivial/servlet/* worker1
</pre>

	<p>This would enable you to put static files on the Apache server, while requests for JSPs or servlets are proxied through to Tomcat.</p>


	<p>This only scratches the surface of the configuration options; a full reference is available at: http://tomcat.apache.org/connectors-doc/.</p>


	<h1>The Test</h1>


	<p>We&#8217;re going to attempt installation of the Roller weblog software. You can get it from:</p>


	<p>http://rollerweblogger.org/page/project</p>


	<p>The aim is to install it as a webapp on the one of your virtual hosts, under the context /roller</p>


	<p>Away you go!</p>


	<h1>Credits</h1>


	<p>Parts of this document were informed by the Apache Tomcat Configuration Reference (http://tomcat.apache.org/tomcat-5.5-doc/config/index.html) and Tomcat User Guide (http://tomcat.apache.org/tomcat-5.5-doc/index.html), though I have not made any verbatim copies of any parts of those documents.</p>


	<h1>Licence</h1>
  </body>
  </html>
