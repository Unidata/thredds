<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>ArrayStructures</title>
</head>

<body>
<h1>ArrayStructures</h1>
<p>In the netCDF-3 data model, all data is represented by multidimensional arrays, stored on disk or in memory in one-dimensional arrays, linearized in row-order. The netCDF-4/CDM data model adds a data type called a <em><strong>Structure</strong></em>, akin to a <em>struct</em> in C or a row in a relational database, which contains constituent data variables that are stored together on disk. A Structure can be multidimensional, like any other data type, and in the CDM the data is represented as <em><strong>ArrayStructure</strong></em> objects, which are  collections of <em><strong>StructureData</strong></em> objects, where a StructureData contains the data for a single instance of the Structure.</p>
<p>Because Structures can be nested inside of each other, the data representation and proccesing of ArrayStructures can be complex. This document explains the API, it's use, and how to create ArrayStructure objects.</p>
<h2>ArrayStructure API</h2>
<p>The public API of ArrayStructure objects is in the abstract class <strong>ucar.ma2.ArrayStructure</strong>:</p>
<pre>public abstract class ucar.ma2.<strong>ArrayStructure</strong> extends ucar.ma2.<strong>Array</strong> {
  List&lt;StructureMembers.Member&gt; <strong>getMembers</strong>();<br />  List&lt;String&gt; <strong>getStructureMemberNames</strong>();
  StructureMembers.Member <strong>findMember</strong>(String memberName);</pre>
<p>One can find an individual <em><strong>StructureMembers.Member</strong></em> from its name, get the list of member names, or get the list of StructureMembers.Member objects. These describe the individual data components of the ArrayStructure: </p>
<pre>  public class ucar.ma2.<strong>StructureMembers.Member</strong> {<br />    String <strong>getName</strong>();<br />    DataType <strong>getDataType</strong>();<br />    int[] <strong>getShape</strong>();
    boolean <strong>isScalar</strong>();
<br />    int <strong>getSize</strong>();<br />    int <strong>getTotalSize</strong>();<br /><br />    String <strong>getUnitsString</strong>();<br />    String <strong>getDescription</strong>();
  }</pre>
<p>Note: You may notice that you can also get a <strong>StructureMembers</strong> object by calling <em>Structure.makeStructureMembers()</em>. You should in general never do that, and use <em>Structure.getVariables()</em> to get the list of Variables in a Structure. Always get <strong>StructureMembers</strong> directly from the ArrayStructure.</p>
<h4>Data Access </h4>
<p>The most general method for accessing the data in a StructureArray is to iterate over the collection of StructureData with a StructureDataIterator:</p>
<pre>    public ucar.ma2.StructureDataIterator <strong>getStructureDataIterator</strong>();
</pre>
<p>Another  general way to access data in an ArrayStructure is to use </p>
<pre>    StructureData <strong>getStructureData</strong>(Index index).</pre>
<p>One can also obtain the StructureData using the record number of the StructureData. For the common case of one-dimensional Structures, the record number is the same as the index: </p>
<pre>    public ucar.ma2.StructureData <strong>getStructureData</strong>(int recno);
</pre>
<p>Make sure that in all these calls, the StructureMembers.Member object is obtained directly from the ArrayStructure, eg using <strong>findMember</strong>(String memberName).<br>
</p>
<p>Often you are not actually interested in the StructureData object, only in the member data. The following method may avoid the overhead of creating the StructureData object:</p>
<pre>   public ucar.ma2.Array <strong>getArray</strong>(int recno, StructureMembers.Member m); </pre>
<p>An Array handles data of all data types and ranks in a uniform way. However, you may want to avoid the overhead of of creating an Array object when you simply want to extract the data as a Java primitive or primitive array, and you are willing to handle the data type and rank explicitly: The following methods are likely (but not guarenteed) to be more efficient, by avoiding unneeded Object creation. These methods must match the member type exactly: </p>
<pre>    public double <strong>getScalarDouble</strong>(int recno, StructureMembers.Member m);<br />    public double[] <strong>getJavaArrayDouble</strong>(int recno, StructureMembers.Member m);
<br />    public float <strong>getScalarFloat</strong>(int recno, StructureMembers.Member m);<br />    public float[] <strong>getJavaArrayFloat</strong>(int recno, StructureMembers.Member m);
<br />    public byte <strong>getScalarByte</strong>(int recno, StructureMembers.Member m));<br />    public byte[] <strong>getJavaArrayByte</strong>(int recno, StructureMembers.Member m);
<br />    public short <strong>getScalarShort</strong>(int recno, StructureMembers.Member m);<br />    public short[] <strong>getJavaArrayShort</strong>(int recno, StructureMembers.Member m);
<br />    public int <strong>getScalarInt</strong>(int recno, StructureMembers.Member m);<br />    public int[] <strong>getJavaArrayInt</strong>(int recno, StructureMembers.Member m);
<br />    public long <strong>getScalarLong</strong>(int recno, StructureMembers.Member m);<br />    public long[] <strong>getJavaArrayLong</strong>(int recno, StructureMembers.Member m);
<br />    public char <strong>getScalarChar</strong>(int recno, StructureMembers.Member m);<br />    public char[] <strong>getJavaArrayChar</strong>(int recno, StructureMembers.Member m);
<br />    public String <strong>getScalarString</strong>(int recno, StructureMembers.Member m);<br />    public String[] <strong>getJavaArrayString</strong>(int recno, StructureMembers.Member m);
<br />    public ucar.ma2.StructureData <strong>getScalarStructure</strong>(int recno, StructureMembers.Member m);<br />    public ucar.ma2.ArrayStructure <strong>getArrayStructure</strong>(int recno, StructureMembers.Member m);
<br />    public ucar.ma2.ArraySequence <strong>getArraySequence</strong>(int recno, StructureMembers.Member m);
</pre>
<p>This method can be used on any type. It converts primitives to their corresponding object types (eg float to Float): </p>
<pre>    public java.lang.Object <strong>getScalarObject</strong>(int recno, StructureMembers.Member m);
</pre>
<p>These two methods convert any numeric type to a float or double: </p>
<pre>
    public float <strong>convertScalarFloat</strong>(int recno, StructureMembers.Member m);<br />    public double <strong>convertScalarDouble</strong>(int recno, StructureMembers.Member m);</pre>
<h4>Unsupported methods </h4>
<p>Because ArrayStructure is a subclass of Array, there are  getter/setter methods for each primitive type. These are not useable, since primitive types cannot be cast to StructureData: </p>
<pre>    public double <strong>getDouble</strong>(ucar.ma2.Index);<br />    public void <strong>setDouble</strong>(ucar.ma2.Index, double);<br />    public float <strong>getFloat</strong>(ucar.ma2.Index);<br />    public void <strong>setFloat</strong>(ucar.ma2.Index, float);<br />    public long <strong>getLong</strong>(ucar.ma2.Index);<br />    public void <strong>setLong</strong>(ucar.ma2.Index, long);<br />    public int <strong>getInt</strong>(ucar.ma2.Index);<br />    public void <strong>setInt</strong>(ucar.ma2.Index, int);<br />    public short <strong>getShort</strong>(ucar.ma2.Index);<br />    public void <strong>setShort</strong>(ucar.ma2.Index, short);<br />    public byte <strong>getByte</strong>(ucar.ma2.Index);<br />    public void <strong>setByte</strong>(ucar.ma2.Index, byte);<br />    public boolean <strong>getBoolean</strong>(ucar.ma2.Index);<br />    public void <strong>setBoolean</strong>(ucar.ma2.Index, boolean);<br />    public char <strong>getChar</strong>(ucar.ma2.Index);<br />    public void <strong>setChar</strong>(ucar.ma2.Index, char);
</pre>
<p>For certain technical reasons these methods also cannot be used: </p>
<pre>
    public ucar.ma2.Array <strong>createView</strong>(ucar.ma2.Index);<br />    public ucar.ma2.Array <strong>copy</strong>();
</pre>
<p>  These methods can be used, but the Object must be of type StructureData: </p>
<pre>    public java.lang.Object <strong>getObject</strong>(ucar.ma2.Index);<br />    public void <strong>setObject</strong>(ucar.ma2.Index, java.lang.Object);

</pre>
<h2>StructureData<a name="StructureData" id="StructureData"></a> API</h2>
<p>StructureData encapsolates all the data in a single record. It is normally contained within an ArrayStructure, and its methods closely parellel the methods of its parent ArrayStructure.</p>
<pre>public abstract class ucar.ma2.<strong>StructureData</strong> {
  List&lt;StructureMembers.Member&gt; <strong>getMembers</strong>();<br />
  StructureMembers.Member <strong>findMember</strong>(String memberName);
</pre>
<p>In the following data access method, each method takes either a member name or a Member object. A common mistake is to assume that the Member object from the ArrayStructure is the same as the one from the StructureData objects that are contained in the ArrayStructure, which is not necessarily the case.  Its slightly more efficient to use the Member object directly, as it avoids a hashMap lookup, but if using the Member directly, you must obtain it from the StructureData. Using the member name is always safe.</p>
<p>The most general ways to access data in a StructureData are:</p>
<pre>    public ucar.ma2.Array <strong>getArray</strong>(String memberName);
    public ucar.ma2.Array <strong>getArray</strong>(StructureMembers.Member m);
</pre>
<p>The following method will handle a scalar object of any type, by converting primitives to their Object type (eg int to Integer): </p>
<pre>    public java.lang.Object <strong>getScalarObject</strong>(String memberName);
    public java.lang.Object <strong>getScalarObject</strong>(StructureMembers.Member m);</pre>
The following  routines may be able to avoid extra Object creation, and so are recommended when efficiency is paramount.
 These require that you know the data types of the member data:
<pre>    public double <strong>getScalarDouble</strong>(String memberName);<br />    public double <em><strong>getScalarDouble</strong></em>(StructureMembers.Member);<br />    public double[] <em><strong>getJavaArrayDouble</strong></em>(String memberName);
    public double[] <em><strong>getJavaArrayDouble</strong></em>(StructureMembers.Member);
<br />    public float <strong>getScalarFloat</strong>(String memberName);<br />    public float <em><strong>getScalarFloat</strong></em>(StructureMembers.Member);<br />    public float[] <em><strong>getJavaArrayFloat</strong></em>(String memberName);
    public float[] <em><strong>getJavaArrayFloat</strong></em>(StructureMembers.Member);
<br />    public byte <strong>getScalarByte</strong>(String memberName);<br />    public byte <em><strong>getScalarByte</strong></em>(StructureMembers.Member);<br />    public byte[] <em><strong>getJavaArrayByte</strong></em>(String memberName);
    public byte[] <em><strong>getJavaArrayByte</strong></em>(StructureMembers.Member);
<br />    public int <strong>getScalarInt</strong>(String memberName);<br />    public int <em><strong>getScalarInt</strong></em>(StructureMembers.Member);<br />    public int[] <em><strong>getJavaArrayInt</strong></em>(String memberName);
    public int[] <em><strong>getJavaArrayInt</strong></em>(StructureMembers.Member);
<br />    public short <strong>getScalarShort</strong>(String memberName);<br />    public short <em><strong>getScalarShort</strong></em>(StructureMembers.Member);<br />    public short[] <em><strong>getJavaArrayShort</strong></em>(String memberName);
    public short[] <em><strong>getJavaArrayShort</strong></em>(StructureMembers.Member);
<br />    public long <strong>getScalarLong</strong>(String memberName);<br />    public long <em><strong>getScalarLong</strong></em>(StructureMembers.Member);<br />    public long[] <em><strong>getJavaArrayLong</strong></em>(String memberName);
    public long[] <em><strong>getJavaArrayLong</strong></em>(StructureMembers.Member);
<br />    public char <strong>getScalarChar</strong>(String memberName);<br />    public char <em><strong>getScalarChar</strong></em>(StructureMembers.Member);<br />    public char[] <em><strong>getJavaArrayChar</strong></em>(String memberName);
    public char[] <em><strong>getJavaArrayChar</strong></em>(StructureMembers.Member);
<br />    public String <strong>getScalarString</strong>(String memberName);<br />    public String <em><strong>getScalarString</strong></em>(StructureMembers.Member);<br />    public String[] <em><strong>getJavaArrayString</strong></em>(String memberName);
    public String[] <em><strong>getJavaArrayString</strong></em>(StructureMembers.Member);</pre>
For members that are themselves Structures,
   the equivalent is:
<pre>    public ucar.ma2.StructureData <strong>getScalarStructure</strong>(String memberName);<br />    public ucar.ma2.StructureData <em><strong>getScalarStructure</strong></em>(StructureMembers.Member);<br />
    public ucar.ma2.ArrayStructure <strong>getArrayStructure</strong>(String memberName);<br />    public ucar.ma2.ArrayStructure <em><strong>getArrayStructure</strong></em>(StructureMembers.Member);

    public ucar.ma2.ArraySequence <em><strong>getArraySequence</strong></em>(String memberName); 
    public ucar.ma2.ArraySequence <em><strong>getArraySequence</strong></em>(StructureMembers.Member); </pre>
The following will return any compatible type as a double or float, but will have extra overhead when the types dont match:
<pre>    public float <em><strong>convertScalarFloat</strong></em>(String memberName);<br />    public float <em><strong>convertScalarFloat</strong></em>(StructureMembers.Member);<br />    public double <em><strong>convertScalarDouble</strong></em>(String memberName);<br />    public double <em><strong>convertScalarDouble</strong></em>(StructureMembers.Member);<br />
</pre>
<h2>Creating ArrayStructures </h2>
<p>IOSP writers need to create ArrayStructure objects for any Structure variables in their files.</p>
<p>ArrayStructure is an abstract class in which the only abstract method is: </p>
<pre>
  abstract protected StructureData <strong>makeStructureData</strong>( ArrayStructure as, int recno);</pre>
<p>However, ArrayStructure has a number of default method implementations that may need to be overriden.</p>
<p>An ArrayStructure uses one of two strategies for StructureData implementations. It either uses a <strong>StructureDataW</strong>, in which each StructureData contains its own data, or it uses a <strong>StructureDataA</strong>, which defers data access back to the ArrayStructure itself. </p>
<p>This method puts the data in column store format </p>
<pre>  public ucar.ma2.Array <strong>getMemberArray</strong>(ucar.ma2.StructureMembers.Member);
</pre>
<blockquote>
  <blockquote>
    <blockquote>
      <blockquote>
        <blockquote>
          <p align="left"><strong>Schematic of ArrayStructure UML</strong> <br>
          </p>
        </blockquote>
      </blockquote>
    </blockquote>
  </blockquote>
</blockquote>
<h3><img src="ArrayStructure.png" width="886" height="473" /></h3>
<h3><br>
  ArrayStructureBB</h3>
<p>ArrayStructureBB uses a <strong>java.nio.ByteBuffer</strong> for data storage and converts  member data only on demand. The member data must be at constant offsets from the start of each record. This offset is stored into each StructureMembers.Member using <strong>StructureMembers.Member.setDataParam</strong>().</p>
<p>Typically the data can be read from disk directly into a ByteBuffer, for example:</p>
<pre>
    // create the ArrayStructure
    StructureMembers members = s.makeStructureMembers();
    for (StructureMembers.Member m : members.getMembers()) {
      Variable v2 = s.findVariable(m.getName());
      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
      m.<strong>setDataParam</strong>((int) (vinfo.begin - recStart)); // the offset from the start of the record
    }
    members.<strong>setStructureSize</strong>(recsize);  // the size of each record is constant

    // create the ArrayStructureBB
    ArrayStructureBB structureArray = new <strong>ArrayStructureBB</strong>(members, new int[]{recordRange.length()});
    byte[] result = structureArray.<strong>getByteBuffer</strong>().array();

    // read the data one record at a time into the ByteBuffer
    int count = 0;
    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
      raf.seek(recStart + recnum * recsize); // where the record starts
      raf.readFully(result, count * recsize, recsize);
      count++;
    }
</pre>
<p>ArrayStructureBB calculates member offsets on demand. By default it assumes that each record is the same size. <strong>ucar.ma2.ArrayStructureBBpos</strong> relaxes this assumption by allowing you to pass in the starting positions in the ByteBuffer of each record. </p>
<p>Member offsets must be the same for each record. However, more complex objects can be stored as an index into a <em>object heap list. </em>For example, this is used to store Strings, which are variable length arrays of UTF-16 charactors. The index of the String in the list is stored (as a 4-byte integer) in the ByteBuffer instead of the String. The String itself is added using  <strong>ArrayStructureBB.addObjectToHeap()</strong>, as in the following code:</p>
<pre>
  int heapIndex = arrayStructureBB.addObjectToHeap(stringData); // add object, and get the index into the Heap
  arrayStructureBB.order( ByteOrder.nativeOrder());             // the heap index is always written in native order
  arrayStructureBB.putInt(bbPos, heapIndex); 	                 // store the index
</pre>

<p>When storing data in an ArrayStructureBB, the heap must be used for both Strings and Sequences. The Object that is added to the heap in the <em>ArrayStructureBB.addObjectToHeap() </em>call:</p>
<ul>
  <li>scalar String: <strong>String</strong></li>
  <li>array od Strings: <strong>String[]</strong></li>
  <li>sequence: <strong>ArraySequence</strong></li>
</ul>
<h4>ArrayStructureBB Nested Structures</h4>
<p>You can accomodate arbitrary nesting of Structures by using a recursive method to set the offsets: </p>
<pre>
  private int setOffsets(StructureMembers members) {
    int offset = 0;
    for (StructureMembers.Member m : members.getMembers()) {
      m.setDataParam(offset);
      offset += m.getSize();

      // set inner offsets
      if (m.getDataType() == DataType.STRUCTURE) 
        setOffsets(m.getStructureMembers());
    }
    return offset;
  }
</pre>
<p>This only works when the nested structures are all of the same, known length. For variable length nested Structures, use ArraySequence. //????? LOOK</p>
<h4>Member data overridding</h4>
<p>NetcdfDataset may widen the type of a Variable when implementing scale/offset attributes. Typically this will cause a byte or short to become a float or double. A StructureDS will post-process the data it gets from the IOSP to implement this. When the IOSP returns an ArrayStructureBB, it is convenient to rewrite just the member data that needs to be widened. This can be done by calculating the new data and calling ArrayStructure.setMemberData(Array).</p>
<pre>  public void <strong>setMemberArray</strong>(ucar.ma2.StructureMembers.Member, ucar.ma2.Array memberArray);</pre>
<p>Requests for data will be satisfied from the  memberArray instead of the ByteBuffer. In order to make this work, the methods in ArrayStructureBB typically check if the member data array exists, and if so defers to the superclass. For example: </p>
<pre>  public double getScalarDouble(int recnum, StructureMembers.Member m) {
    if (m.getDataArray() != null) return super.getScalarDouble(recnum, m);
    ...
  }
 </pre>
<h3>ArrayStructureMA</h3>
<p>ArrayStructureMA stores its member data in <em>column-store form</em>, where each member's data is stored in a single Array across all rows. The member Arrays are stored with <strong>StructureMembers.Member.setDataArray()</strong>, for example: </p>
<pre>
    StructureMembers members = structure.<strong>makeStructureMembers</strong>();
    ArrayStructureMA ama = new <strong>ArrayStructureMA</strong>(members, shape);
    ArrayInt.D1 timeArray = new ArrayInt.D1(shape[0]);
    ArrayObject.D1 nameArray = new ArrayObject.D1(String.class, shape[0]);

    for (StructureMembers.Member m : members.getMembers()) {
      if (m.getName().equals("time"))
        m.setDataArray(timeArray);
      else
        m.setDataArray(nameArray);
    }
</pre>
<h4>ArrayStructureMA Nested Structures</h4>
<p>A nested Structure inside of an ArrayStructureMA would be represented by another ArrayStructureMA,  when the nested structures are all of the same, known length. This inner ArrayStructureMA would represent all of the inner Structures across all rows of the outer Structure. </p>
<h3>ArrayStructureW</h3>
<p>ArrayStructureW defers data reading to the StructureData objects. To use it, one  constructs all of the StructureData objects and passes them to the ArrayStructureW, for example: </p>
<pre>  public <strong>ArrayStructureW</strong>(StructureMembers members, int[] shape, StructureData[] sdata);
</pre>
<p>All of the work is  in constructing the StructureData objects. </p>
<hr />
<p>&nbsp;</p>
<address>
<img src="../nc.gif" width="64" height="64" /> This document is maintained by <a href="mailto:caron@unidata.ucar.edu">John Caron</a> and was last updated on Aug 05, 2008
</address>
</body>
</html>
