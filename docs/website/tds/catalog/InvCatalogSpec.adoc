:source-highlighter: coderay
[[threddsDocs]]
:gloss: ../Glossary.adoc
:toc:

= THREDDS Client Catalog Specification

== Overview

A THREDDS catalog is a way to describe an inventory of available datasets.
These catalogs provide a simple hierarchical structure for organizing a collection of datasets, an access method for each dataset,
a human understandable name for each dataset, and a structure on which further descriptive information can be placed.

This document specifies the semantics of a THREDDS catalog, as well as its representation as an XML document.
It is written to help clients read and understand THREDDS catalogs recieved from a server.

Related resources:

* Catalog <<../tutorial/CatalogPrimer.adoc#,Primer>>
* Catalog link:Example1.0rc8.xml[Example]
* Catalog http://www.unidata.ucar.edu/schemas/thredds/InvCatalog.1.2.xsd[XML Schema]
* <<InvCatalogServerSpec#,Server-side catalog specification>>

[[baseElements]]
== Base Catalog Elements

[[catalog]]
=== _catalog_ element

[source,xml]
----
<xsd:element name="catalog">
  <xsd:complexType>
    <xsd:sequence>
      <xsd:element ref="service" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element ref="property" minOccurs="0" maxOccurs="unbounded" />
      <xsd:element ref="dataset" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>

    <xsd:attribute name="base" type="xsd:anyURI"/>
    <xsd:attribute name="name" type="xsd:string" />
    <xsd:attribute name="expires" type="dateType"/>
    <xsd:attribute name="version" type="xsd:token" default="1.2" />
  </xsd:complexType>
</xsd:element>
----

The _catalog_ element is the top-level element. It may contain zero or
more <<service>> elements, followed by zero or more <<property>> elements,
followed by one or more <<dataset>> elements. The _base_ is
used to resolve any reletive URLs in the catalog such as catalogRefs,
services, etc. It is usually the URL of the catalog document itself.
Optionally the catalog may have a display __name__. The optionl _expires_
attribute indeicates when this catalog should be reread. If not present, assume you must reread each time.
The value of the _version_ attribute indicates the version of the InvCatalog specification to which the catalog conforms.

Example of simplest useful catalog. Note the necessary presence of the
http://en.wikipedia.org/wiki/XML_namespace[xml namespace] attribute
_xmlns="http://www.unidata.ucar.edu/namespaces/thredds/InvCatalog/v1.0"_
on the catalog element.

[source,xml]
----
 <catalog xmlns="http://www.unidata.ucar.edu/namespaces/thredds/InvCatalog/v1.0" >
   <service name="aggServer" serviceType="DODS"  base="http://acd.ucar.edu/thredds/dodsC/" />
   <dataset name="SAGE III Ozone Loss" urlPath="sage.nc">
     <serviceName>aggServer</serviceName>
   </dataset>
 </catalog>
----

[[service]]
=== _service_ element

[source,xml]
----
<xsd:element name="service">
 <xsd:complexType>
  <xsd:sequence>
    <xsd:element ref="property" minOccurs="0" maxOccurs="unbounded" />
    <xsd:element ref="service" minOccurs="0" maxOccurs="unbounded" />
  </xsd:sequence>

  <xsd:attribute name="name" type="xsd:string" use="required" />
  <xsd:attribute name="base" type="xsd:string" use="required" />
  <xsd:attribute name="serviceType" type="serviceTypes" use="required" />
  <xsd:attribute name="desc" type="xsd:string"/>
  <xsd:attribute name="suffix" type="xsd:string" />
 </xsd:complexType>
</xsd:element>
----

A _service_ element represents a data access service and allows basic
data access information to be factored out of _dataset_ and _access_
elements.

The _name_ attribute is required and its value must be unique for all
service elements within the catalog. These unique names are used in the
definition of a link:#Dataset_Access_Methods[dataset access method] to
refer to a specific service element. The mandatory _base_ attribute and
the optional _suffix_ attribute are both used in the construction of the
dataset URL (see link:#constructingURLs[constructing URLS]). The _base_
may be an absolute URL or it may be relative to the catalog’s base URL.
The _service_ element has a _serviceType_ attribute whose value is
typically one of the <<serviceType>> values.
The optional _desc_ attribute allows you to give a human-readable description of the service.

A _service_ element may contain 0 or more <<property>>
elements to allow for the encoding of additional, service-specific information.

Only _service_ element with _serviceType="Compound"_ may have nested
service elements. Compound services are used when there is
more than one way to access a dataset (e.g.__DODS__ and __FTP__), *and*
the access URLs are the same except for the service base. Nested
_service_ elements may also be used directly by _dataset_ or _access_
elements, and so must have unique names.

Example:

[source,xml]
----
 <service name="mcidasServer" serviceType="ADDE" base="http://thredds.ucar.edu/thredds/adde/" />
----

Example with service base URL relative to catalog URL (see
link:#constructingURLs[constructing URLS] for how the resolved URL is created):

[source,xml]
----
 <service name="this" serviceType="OPENDAP" base="/thredds/dodsC/" />
----

[[dataset]]
=== _dataset_ type

[source,xml]
----
<xsd:element name="dataset" type="DatasetType" />
<xsd:complexType name="DatasetType">
  <xsd:sequence>
    <xsd:group ref="threddsMetadataGroup" minOccurs="0" maxOccurs="unbounded" />
    <xsd:element ref="access" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="dataset" minOccurs="0" maxOccurs="unbounded"/>
  </xsd:sequence>

  <xsd:attribute name="name" type="xsd:string" use="required"/>
  <xsd:attribute name="alias" type="xsd:token"/>
  <xsd:attribute name="authority" type="xsd:string"/> <!-- deprecated : use element -->
  <xsd:attribute name="collectionType" type="collectionTypes"/>
  <xsd:attribute name="dataType" type="dataTypes"/> <!-- deprecated : use element -->
  <xsd:attribute name="harvest" type="xsd:boolean"/>
  <xsd:attribute name="ID" type="xsd:token"/>
  <xsd:attribute name="restrictAccess" type="xsd:string"/>

  <xsd:attribute name="serviceName" type="xsd:string" /> <!-- deprecated : use element -->
  <xsd:attribute name="urlPath" type="xsd:token" />
</xsd:complexType>
----

A _dataset_ element represents a named, logical set of data at a level
of granularity appropriate for presentation to a user. A dataset is
*_link:#directDataset[direct]_* if it contains at least one
link:#Dataset_Access_Methods[dataset access method], otherwise it is
just a container for nested datasets, called a
_*link:#collection[collection]*_ dataset. The name of the dataset
element should be a human readable name that will be displayed to users.
Multiple access methods specify different services for accessing the
same dataset.

A dataset must have a _name_ attribute, and may have other attributes.
If an _ID_ attribute is given, its value must be unique within the
catalog. We highly recommend that all datasets be given a unique ID.
This allows for a number of capabilities including XPath ID reference. A
dataset may have a naming _authority_ specified within itself or in a
parent dataset. (The _authority_ attribute has been deprecated. Instead
you should use the _authority_ element which can be contained in a
_dataset_ or _metadata_ element.) If a dataset has an _ID_ and an
_authority_ attribute, then the combination of the two should be
globally unique for all time. If the same dataset is specified in
multiple catalogs, then the combination of its _authority_ and _ID_
should be identical if possible.

A _dataset_ element contains any number of elements from the
link:#threddsMetadataGroup[threddsMetadataGroup] in any order. These are
followed by 0 or more <<access>> elements, followed by 0 or
more nested _dataset_ elements (actually you can use any element in the
dataset substitution group: dataset or catalogRef). The data represented
by a nested dataset element should be a subset, a specialization or in
some other sense "contained" within the data represented by its parent
dataset element.

The <<collectionType>> attribute is used to
indicate that the dataset is a link:#coherentDataset[coherent
collection] and the type of the collections coherence. A datasets data
type is very useful to clients so they know how to present the data to
the user. (You can also use a link:#dataType_descrip[_dataType_] element
which can be contained in a _dataset_ or _metadata_ element. This allows
the data type to be inherited.) If the _harvest_ attribute is true, then
this dataset is available to be placed into digital libraries or other
discovery services. Note that the harvest attribute should be carefully
placed to get the right level of granularity for digital library
entries, and is typically placed on link:#collection[collection]
datasets.

If you want the same dataset to appear in multiple places in the same
catalog, use an _alias_ attribute. Define it in one place (with all
apropriate metadata), then wherever else it should appear, make a
dataset with an alias to it, whose value is the _ID_ of the defined
dataset. ( Note it may not refer to a dataset in another catalog
referred to by a _catalogRef_ element.) In this case, any other
properties of the dataset are ignored, and the dataset to which the
alias refers is used in its place.

The _dataset_ element’s _serviceName_ attribute has been deprecated in
favor of the _serviceName_ element which can be contained in a _dataset_
or _metadata_ element. (The _access_ element’s _serviceName_ attribute
is still necessary.) The urlPath attribute, in combination with the
applicable serviceName, is used to specify
link:#Dataset_Access_Methods[data access methods]. When you have more
than one way to access a dataset, either explicitly define them using
more than one nested <<access> elements, or use a link:#compoundService[compound service].

Examples:

[source,xml]
----
<dataset name="DC8 flight 1999-11-19" urlPath="SOLVE_DC8_19991119.nc">
  <serviceName>agg</serviceName>
</dataset>

<dataset ID="SOLVE_DC8_19991119" name="DC8 flight 1999-11-19, 1 min merge">
  <metadata xlink:href="http://dataportal.ucar.edu/metadata/tracep_dc8_1min_05"/>
  <access serviceName="disk" urlPath="SOLVE_DC8_19991119.nc"/>
</dataset>
----

An example using an alias; in this case the dataset referred to
logically replaces the alias dataset.

[source,xml]
----
<dataset name="Station Data">
  <dataset name="Metar data" urlPath="cgi-bin/MetarServer.pl?format=qc" />
  <dataset name="Level 3 Radar data" urlPath="cgi-bin/RadarServer.pl?format=qc" />
  <dataset name="Alias to SOLVE dataset" alias="SOLVE_DC8_19991119"/>
</dataset>
----

[[access]]
=== _access_ element

[source,xml]
----
<xsd:element name="access">
  <xsd:complexType>
    <xsd:sequence>
      <xsd:element ref="dataSize" minOccurs="0"/>
    </xsd:sequence>
    <xsd:attribute name="urlPath" type="xsd:token" use="required"/>
    <xsd:attribute name="serviceName" type="xsd:string"/>
    <xsd:attribute name="dataFormat" type="dataFormatTypes"/>
  </xsd:complexType>
</xsd:element >
----

An _access_ element specifies how a dataset can be accessed through a
data <<service>>. It always refers to the dataset that it
is immediately contained within.

The _serviceName_ refers to the unique name of a service element. The
_urlPath_ is appended to the service’s base to get the dataset URL (see
link:#constructingURLs[constructing URLs]). The
_link:#dataFormatType[dataFormat]_ is important when the
link:#serviceTypes[_serviceType_] is a bulk transport like _FTP_ or
__HTTP__, as it specifies the format of the transferred file. It is not
needed for client/server protocols like DODS or ADDE.

An _access_ element may contain an optional <<dataSize>>
element to specify how large the dataset would be if it were to be
copied to the client.

Example:

[source,xml]
----
<access serviceName="ftpServer" urlPath="SOLVE_DC8_19991119.nc" dataFormat="NetCDF" />
----

The common case is that the access element is __implicit__, based on the
dataset’s _serviceName_ and __urlPath__.

[[catalogRef]]
=== _catalogRef_ element

[source,xml]
----
<xsd:element name="catalogRef" substitutionGroup="dataset">
  <xsd:complexType>
    <xsd:complexContent>
      <xsd:extension base="DatasetType">
        <xsd:attributeGroup ref="XLink"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:element>
----

A _catalogRef_ element refers to another THREDDS catalog that logically
is a nested _dataset_ inside this parent catalog. This is used to
separately maintain catalogs and to break up large catalogs. THREDDS
clients should not read the referenced catalog until the user explicitly
requests it, so that very large dataset collections can be represented
with _catalogRef_ elements without large delays in presenting them to
the user. The referenced catalog is not textually substituted into the
containing catalog, but remains a self-contained object. The referenced
catalog must be a valid THREDDS catalog, but it does not have to match
versions with the containing catalog.

The link:#XLink[XLink attributeGroup] allows you to add Xlink
attributes, a generalization of HTTP hrefs. The value of _xlink:href_ is
the URL of the referenced catalog. It may be absolute or relative to the
parent catalog URL. The value of _xlink:title_ is displayed as the name
of the dataset that the user can click on to follow the XLink.

A catalogRef element is in the dataset substitutionGroup, so it can be
used wherever a dataset element can be used. It is an extension of a
DatasetType, so any of dataset’s nested elements and attributes can be
used in it. This allows you to add enhanced metadata to a catalogRef.
However you should not add nested datasets, as these will be ignored.
Furthermore, metadata elements are NOT copied to the referenced catalog,
so they are used only to display information to the user before the user
downloads the referenced catalog.

Example:

[source,xml]
----
<catalogRef xlink:title="NCEP Model Data" xlink:href="http://yerserv/uniModels.xml"/>
----

[[XLink]]
=== _XLink_ attribute group

[source,xml]
----
  <xsd:attributeGroup name="XLink">
    <xsd:attribute ref="xlink:href" />
    <xsd:attribute ref="xlink:title" />
    <xsd:attribute ref="xlink:show"/>
    <xsd:attribute ref="xlink:type" />
  </xsd:attributeGroup>
----

These are attributes from the http://www.w3.org/TR/xlink/[XLink
specification] that are used to point to another web resource. The
_xlink:href_ attribute is used for the URL of the resource itself. The
__xlink:title__attribute is a human-readable description of the linked
resource. THREDDS clients can display the title to the user as
appropriate. These are the only two attributes currently used in the
THREDDS software.You can also add the _xlink:type_ or _xlink:show_
attributes__.__

Example:

[source,xml]
----
<documentation xlink:href="http://cloud1.arc.nasa.gov/solve/" xlink:title="SOLVE home page"/>
----

[[dlElements]]
== THREDDS Metadata Elements

These are catalog elements that are used in Digital Libraries entries,
discovery centers, and for annotation and documentation of datasets.

[[threddsMetadataGroup]]
=== _threddsMetadataGroup_ element group

[source,xml]
----
<xsd:group name="threddsMetadataGroup">
  <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element name="documentation" type="documentationType"/>
    <xsd:element ref="metadata"  />
    <xsd:element ref="property"  />

    <xsd:element ref="contributor"/>
    <xsd:element name="creator" type="sourceType"/>
    <xsd:element name="date" type="dateTypeFormatted"/>
    <xsd:element name="keyword" type="controlledVocabulary" />
    <xsd:element name="project" type="controlledVocabulary" />
    <xsd:element name="publisher" type="sourceType"/>

    <xsd:element ref="geospatialCoverage"/>
    <xsd:element name="timeCoverage" type="timeCoverageType"/>
    <xsd:element ref="variables"/>

    <xsd:element name="dataType" type="dataTypes"/>
    <xsd:element name="dataFormat" type="dataFormatTypes"/>
    <xsd:element name="serviceName" type="xsd:string" />
    <xsd:element name="authority" type="xsd:string" />
    <xsd:element ref="dataSize"/>
  </xsd:choice>
</xsd:group>
----

The elements in the _threddsMetadataGroup_ may be used as nested
elements of both _link:#dataset[dataset]_ and _link:#metadata[metadata]_
elements. There may be any number of them in any order, but more than
one geospatialCoverage, timeCoverage, dataType, dataFormat, serviceName,
or authority elements will be ignored.

A _link:#documentationType[documentation]_ element contains (or points
to) _human-readable_ content. Documentation content may be displayed to
users by THREDDS clients as appropriate for the situation. A
_link:#metadataElement[metadata]_ element is a container for
_machine-readable_ information structured in XML. A
_link:#property[property]_ element is an arbitrary name/value pair.

The next group of elements are used primarily for use in Digital
Libraries. A link:#contributorType[_contributor_] element is typically a
person’s name with an optional _role_ attribute, documenting some
person’s contribution to the dataset. A _creator_ element ____indicates
who created the dataset. A _date_ element is used to document various
dates associated with the dataset, using one of the
link:#dateTypeEnum[date type enumerations]. A _keyword_ element is used
for library searches, while a _project_ element specifies what
scientific project the dataset belongs to. Both have type
link:#controlledVocabulary[controlledVocabulary], which allows an
optional vocabulary attribute to specify if you are using words from a
restricted list, for example DIF. A _publisher_ element indicates who is
responsible for serving the dataset. Both a contibutor and publisher
element use the link:#sourceType[sourceType] definition.

The next group of elements are used in search services. The
_link:#geospatialCoverageType[geospatialCoverage]_ element specifies a
lat/lon bounding box for the data. The
_link:#timeCoverageType[timeCoverage]_ element specifies the range of
dates that the dataset covers. The _link:#variablesType[variables]_
element specifies the names of variables contained in the datasets, and
ways to map the names to standard vocabularies.

The _dataType_ element is used to indicate the high-level semantic type
of the dataset (e.g., grid, point, trajectory) and can be used by
clients to decide how to display the data. The values come from the
link:#dataType_types_[data type enumeration] which are intended to map
to the scientific data types from
the http://www.unidata.ucar.edu/software/netcdf/CDM/[Common Data Model
(CDM)]. The _dataFormat_ element indicates the format of the data and is
mainly used so clients can determine how to read data that is accessed
using a bulk access method. The data format values come from the
link:#dataFormatType[data format enumeration]. The _serviceName_ element
is a reference to a _service_ element; its content must match the _name_
of a _service_ element in the catalog. The service referenced by a
dataset is used in the link:#constructingURLs[construction of access
method URLs] for that dataset. (This element and the _serviceName_
attribute of an _access_ element are both used in the same way.) The
_authority_ element is used to further refine dataset IDs with the goal
of allowing for link:#globally_unique_id[globally unique IDs]. The
_dataSize_ element can be used to specify how large the dataset would be
if it were to be copied to a client.

Including any of these elements in a metadata element with its _inherit_
attribute set to "true" means that they apply to the containing
dataset and any nested datasets.

If your intention is to enable THREDDS to write entries into a Digital
Library, you should to be aware of
<<../reference/DigitalLibraries,how elements are mapped to
Digital Libraries>>. For example, you will probably want to add a
_documentation_ element with type _summary_ as its content will be the
description of the dataset in the DL entry. Another documentation
element you may need has type _rights_ which specifies what restrictions
there are on the dataset usage.

Examples:

[source,xml]
----
<documentation type="summary"> The SAGE III Ozone Loss and Validation Experiment (SOLVE)
 was a measurement campaign designed to examine the processes controlling ozone levels
 at mid- to high latitudes. Measurements were made in the Arctic high-latitude
 region in winter using the NASA DC-8 and ER-2 aircraft,
 as well as balloon platforms and ground-based instruments. </documentation>
----

[source,xml]
----
<documentation type="rights"> Users of these data files are expected  to follow the NASA
  ESPO Archive guidelines for use of the SOLVE data, including consulting with the PIs
  of the individual measurements  for interpretation and credit.
</documentation>

<keyword>Ocean Biomass</keyword>

<project vocabulary="DIF">NASA Earth Science Project Office, Ames Research Center</project>
----

[[documentation]]
=== _documentation_ type

[source,xml]
----
<xsd:complexType name="documentationType" mixed="true">
  <xsd:sequence>
    <xsd:any namespace="http://www.w3.org/1999/xhtml" minOccurs="0" maxOccurs="unbounded"
         processContents="strict"/>
  </xsd:sequence>

  <xsd:attribute name="type" type="documentationEnumTypes"/>
  <xsd:attributeGroup ref="XLink" />
</xsd:complexType>
----

The _documentation_ element may contain arbitrary plain text content, or
XHTML.We call this kind of content "human readable" information. It
has an optional link:#docTypeEnum[documentation type] attribute, such as
summary, funding, history, etc.

The _documentation_ element may also contain an
http://www.w3.org/TR/xlink/[XLink] to an HTML or plain text web page.
This allows you to point to external web references, and also allows you
to factor out common documentation which can be referenced from multiple
places. Note it should not link to an XML page (unless its XHTML), use
the link:#metadata[metadata] element instead.

Examples:

[source,xml]
----
<documentation xlink:href="http://espoarchive.nasa.gov/archive/index.html"
    xlink:title="Earth Science Project Office Archives"/>

<documentation>Used in doubled CO2 scenario</documentation>
----

[[metadata]]
=== _metadata_ element

[source,xml]
----
<xsd:element name="metadata">
  <xsd:complexType>
    <xsd:choice>
      <xsd:group ref="threddsMetadataGroup" minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0" maxOccurs="unbounded" processContents="strict"/>
    </xsd:choice>

    <xsd:attribute name="inherited" type="xsd:boolean" default="false" />
    <xsd:attribute name="metadataType" type="metadataTypeEnum"  />
    <xsd:attributeGroup ref="XLink" />
  </xsd:complexType>
</xsd:element>
----

A _metadata_ element contains or refers to structured information (in
XML) about datasets, which is used by client programs to display,
describe, or search for the dataset.  We call this kind of content
"machine readable" information.

A _metadata_ element contains any number of elements from the
link:#threddsMetadataGroup[threddsMetadataGroup] in any order, OR it
contains any other well-formed XML elements, as long as they are in a
namespace other than the THREDDS namespace. It may also contain an XLink
to another XML document, whose top-level element should be a valid
metadata element (see example below). Note it should not link to an HTML
page, use the link:#documentation[documentation] element instead.

The _inherited_ attribute indicates whether the metadata is inherited by
nested datasets. If true, the metadata element becomes logically part of
each nested dataset. (The metadata always applies to the containing
dataset whether _inherited_ is true or not.)

The _metadataType_ attribute may have any value, but the "well known"
values are listed in the link:#metadataType[metadataType] enumeration.
To use metadata elements from the
link:#threddsMetadataGroup[threddsMetadataGroup], do not include the
metada type attribute (or set it to "THREDDS"). To use your own
elements, give it a metadata type, and add a namespace declaration (see
example below).

Examples:

[source,xml]
----
// contains Thredds metadata
<metadata inherited="true">
  <contributor role="data manager">John Smith</contributor>
  <keyword>Atmospheric Science</keyword>
  <keyword>Aircraft Measurements</keyword>
  <keyword>Upper Tropospheric Chemistry</keyword>
</metadata>

// link to external file containing Thredds metadata
<metadata xlink:href="http://dataportal.ucar.edu/metadata/solveMetadata.xml"
   xlink:title="Solve metadata" />
----

If you use an XLink, it should point to a document whose top element is
a metadata element, which declares the THREDDS namespace:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<metadata  xmlns="http://www.unidata.ucar.edu/namespaces/thredds/InvCatalog/v1.0">
  <contributor role="Investigator">Mashor Mashnor</contributor>

  <abstract>
   This project aims to determine the physiological adaptations of algae to the
   extreme conditions of Antarctica.
  </abstract>

  <publisher>
     <name vocabulary="DIF">AU/AADC</name>
     <long_name vocabulary="DIF">Australian Antarctic Data Centre, Australia</long_name>
     <contact url="http://www.aad.gov.au/default.asp?casid=3786" email="metadata@aad.gov.au"/>
  </publisher>

</metadata>
----

When using elements from another namespace, all the subelements should
be in the same namespace, which should be declared in the metadata
element:

[source,xml]
----
<metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
  <dc:title>Goto considered harmful</dc:title >
  <dc:description>The unbridled use of the go to statement has an immediate consequence
      that it becomes terribly
        hard to find a meaningful set of coordinates in which to describe the process progress.
  </dc:description>
  <dc:author>Edsger W. Dijkstra</dc:author>
</metadata>
----

If you use an XLink to point to elements from another namespace, add a
metadataType attribute:

[source,xml]
----
<metadata xlink:href="http://www.unidata.ucar.edu/metadata/ncep/dif.xml"
    xlink:title="NCEP DIF metadata" metadataType="DublinCore"/>
----

whose xlink:href should point to a document whose top element is a
metadata element, which declares a different namespace (note you also
still need to declare the THREDDS namespace):

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<metadata  xmlns="http://www.unidata.ucar.edu/namespaces/thredds/InvCatalog/v1.0"
           xmlns:dc="http://purl.org/dc/elements/1.1/">
  <dc:title>Goto considered harmful</dc:title >
  <dc:description>The unbridled use of the go to statement has an immediate consequence
      that it becomes terribly
        hard to find a meaningful set of coordinates in which to describe the process progress.
  </dc:description>
  <dc:author>Edsger W. Dijkstra</dc:author>
</metadata>
----

This equivalent declaration makes the other namespace the default
namespace:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<cat:metadata  xmlns:cat="http://www.unidata.ucar.edu/namespaces/thredds/InvCatalog/v1.0"
               xmlns="http://purl.org/dc/elements/1.1/">
  <title>Goto considered harmful</title >
  <description>The unbridled use of the go to statement has an immediate consequence
      that it becomes terribly
        hard to find a meaningful set of coordinates in which to describe the process progress.
  </description>
  <author>Edsger W. Dijkstra</author>
</cat:metadata>
----

[[property]]
=== _property_ element

[source,xml]
----
<xsd:element name="property">
  <xsd:complexType>
    <xsd:attribute name="name" type="xsd:string"/>
    <xsd:attribute name="value" type="xsd:string"/>
  </xsd:complexType>
</xsd:element>
----

Property elements are arbitrary name/value pairs to associate with a
link:#catalog[catalog], link:#dataset[dataset] or link:#service[service]
element. Properties on datasets are added as global attributes to the
THREDDS data model objects. Generally there may be multiple properties having the same name.

Example:

[source,xml]
----
<property name="Conventions" value="WRF" />
----

[[source]]
=== _source_ type

[source,xml]
----
<xsd:complexType name="sourceType">
  <xsd:sequence>
    <xsd:element name="name" type="controlledVocabulary"/>
    <xsd:element name="contact">
      <xsd:complexType>
        <xsd:attribute name="email" type="xsd:string" use="required"/>
        <xsd:attribute name="url" type="xsd:anyURI"/>
      </xsd:complexType>
    </xsd:element>
  </xsd:sequence>
</xsd:complexType>
----

This is used by the link:#creator[creator] and
link:#publisher[publisher] elements to specify roles of responsibility
for the dataset. It must have a _name_ and _contact_ element. The name
element has an optional vocabulary attribute if it come from a
link:#controlledVocabulary[controlled vocabulary]. The _contact_ element
has attributes to specify a web _url_ and an _email_ address.

Example:

[source,xml]
----
<publisher>
  <name vocabulary="DIF">UCAR/NCAR/CDP > Community Data Portal, National Center for Atmospheric
    Research, University Corporation for Atmospheric Research</name>
  <contact url="http://dataportal.ucar.edu" email="cdp@ucar.edu"/>
</publisher>
----

[[contributor]]
=== _contributor_ element

[source,xml]
----
<xsd:element name="contributor">
  <xsd:complexType>
    <xsd:simpleContent>
      <xsd:extension base="xsd:string">
        <xsd:attribute name="role" type="xsd:string" use="required"/>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>
</xsd:element>
----

A _contributor_ is simply a person’s name with an optional _role_
attribute that specifies the role that the person plays with regard to
this dataset. The roles can be any string, ie they are not from a
controlled vocabulary.

Example:

[source,xml]
----
<contributor role="PI">Jane Doe</contributor>
----

[[geospatialCoverage]]
=== _geospatialCoverage_ element

[source,xml]
----
  <xsd:element name="geospatialCoverage">
   <xsd:complexType>
    <xsd:sequence>
      <xsd:element name="northsouth" type="spatialRange" minOccurs="0" />
      <xsd:element name="eastwest" type="spatialRange" minOccurs="0" />
      <xsd:element name="updown" type="spatialRange" minOccurs="0" />
      <xsd:element name="name" type="controlledVocabulary" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>

    <xsd:attribute name="zpositive" type="upOrDown" default="up"/>
   </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="spatialRange">
   <xsd:sequence>
     <xsd:element name="start" type="xsd:double"  />
     <xsd:element name="size" type="xsd:double" />
     <xsd:element name="resolution" type="xsd:double" minOccurs="0" />
     <xsd:element name="units" type="xsd:string" minOccurs="0" />
   </xsd:sequence>
  </xsd:complexType>

  <xsd:simpleType name="upOrDown">
   <xsd:restriction base="xsd:token">
     <xsd:enumeration value="up"/>
     <xsd:enumeration value="down"/>
   </xsd:restriction>
  </xsd:simpleType>
----

A geospatialCoverage element specifies a lat/lon bounding box, and an
altitude range that the data covers.

The _northsouth_ and _eastwest_ elements should both be set to specify a
lat/lon bounding box. The default units are _*degrees_north*_ and
__*degrees_east*__, respectively. The _updown_ element specifies the
altitude range, with default units in **_meters_**. A _zpositive_ value
of *_up_* means that z increases up, like units of height, while a value
of *_down_* means that z increases downward, like units of pressure or
depth. The *spatialRange* elements indicate that the range goes from
_start_ to __start + size__. Use the _resolution_ attribute to indicate
the data resolution.

You can optionally add any number of names to describe the covered
region. An important special case is global coverage, where you should
use the name *_global_* (see example below):

Example:

[source,xml]
----
 <geospatialCoverage zpositive="down">
   <northsouth>
     <start>10</start>
     <size>80</size>
     <resolution>2</resolution>
     <units>degrees_north</units>
   </northsouth>
   <eastwest>
     <start>-130</start>
     <size>260</size>
     <resolution>2</resolution>
     <units>degrees_east</units>
   </eastwest>
   <updown>
     <start>0</start>
     <size>22</size>
     <resolution>0.5</resolution>
     <units>km</units>
   </updown>
  </geospatialCoverage>

  <geospatialCoverage>
    <name vocabulary="Thredds">global</name>
  </geospatialCoverage>
----

[[timeCoverage]]
=== _timeCoverage_ type

[source,xml]
----
<xsd:complexType name="timeCoverageType">
  <xsd:sequence>
    <xsd:choice minOccurs="2" maxOccurs="3" >
      <xsd:element name="start" type="dateTypeFormatted"/>
      <xsd:element name="end" type="dateTypeFormatted"/>
      <xsd:element name="duration" type="duration"/>
    </xsd:choice>
    <xsd:element name="resolution" type="duration" minOccurs="0"/>
  </xsd:sequence>
</xsd:complexType>
----

A timeCoverage element specifies a date range. The date range can be
specified in three ways: 1) by giving both a _start_ and an _end_
link:#dateType[date type] element; 2) by specifying a _start_ element
and a link:#durationType[_duration_] element; or 3) by specifying an
_end_ element and a _duration_ element. The optional resolution element
should be used to indicate the data resolution for time series data.

Example:

[source,xml]
----
<timeCoverage>
  <start>1999-11-16T12:00:00</start>
  <end>present</end>
</timeCoverage>

<timeCoverage>
  <start>1999-11-16T12:00:00</start>
  <duration>P3M</duration>  // 3 months
</timeCoverage>

<timeCoverage>   // 10 days before the present up to the present
  <end>present</end>
  <duration>10 days</duration>
  <resolution>15 minutes</resolution>
</timeCoverage>
----

[[date]]
=== _date_ type

[source,xml]
----
<xsd:simpleType name="dateType">
  <xsd:union memberTypes="xsd:date xsd:dateTime udunitDate">
    <xsd:simpleType>
      <xsd:restriction base="xsd:token">
        <xsd:enumeration value="present"/>
      </xsd:restriction>
    </xsd:simpleType>
  </xsd:union>
</xsd:simpleType>

<xsd:simpleType name="udunitDate">
  <xsd:restriction base="xsd:string">
    <xsd:annotation>
      <xsd:documentation>Must conform to complete udunits date string, eg
          "20 days since 1991-01-01"</xsd:documentation>
    </xsd:annotation>
  </xsd:restriction>
</xsd:simpleType>
[source,xml]
----

A _*dateType*_ follows the <<{gloss}#W3C_Date,W3C Date>> profile of ISO 8601 for date/time formats].
Note that it is a simple type, so that it can be used as the type of an attribute. It can be one of the following:

1.  an http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/#date[xsd:date], with form "CCYY-MM-DD"
2.  an http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/#dateTime[xsd:dateTime]
with form "CCYY-MM-DDThh:mm:ss", "CCYY-MM-DDThh:mm:ssZ" or "CCYY-MM-DDThh:mm:ss-hh:ss"
3.  a valid http://www.unidata.ucar.edu/packages/udunits/[udunits] date string
4.  the string "present"

Examples:

[source,xml]
----
<start>1999-11-16</start>
<start>1999-11-16T12:00:00</start> // implied UTC
<start>1999-11-16T12:00:00Z</start> // explicit UTC
<start>1999-11-16T12:00:00-05:00</start> // EST time zone specified
<start>20 days since 1991-01-01</start>
<start>present</start>
----

[[dateTypeFormatted]]
=== _dateTypeFormatted_ type

[source,xml]
----
<xsd:complexType name="dateTypeFormatted">
  <xsd:simpleContent>
    <xsd:extension base="dateType">
      <xsd:attribute name="format" type="xsd:string" /> // from java.text.SimpleDateFormat
      <xsd:attribute name="type" type="dateEnumTypes" />
    </xsd:extension>
  </xsd:simpleContent>
</xsd:complexType>
----

A _*dateTypeFormatted*_ extends dateType by allowing an optional,
user-defined _format_ attribute and an optional _type_ attribute. The
*_format_* string follows the specification in
**java.text.SimpleDateFormat**. The link:#dateTypeEnum[values] of the
*_type_* attribute are taken from the Dublin Core date types.

Example:

[source,xml]
----
<start format="yyyy DDD" type="created">1999 189</start> <!-- year, day of year -->
----

----
_Example_Format_String___________Example_Text___________________
"yyyy.MM.dd G 'at' HH:mm:ss z"  2001.07.04 AD at 12:08:56 PDT
"EEE, MMM d, "yy"              Wed, Jul 4, '01
"K:mm a, z"                     0:08 PM, PDT
"yyyyy.MMMMM.dd GGG hh:mm aaa"  02001.July.04 AD 12:08 PM
"EEE, d MMM yyyy HH:mm:ss Z"    Wed, 4 Jul 2001 12:08:56 -0700
"yyMMddHHmmssZ"                 010704120856-0700
----

[[duration]]
=== _duration_ type

[source,xml]
----
<xsd:simpleType name="duration">
  <xsd:union memberTypes="xsd:duration udunitDuration" />
</xsd:simpleType>

<xsd:simpleType name="udunitDuration">
  <xsd:restriction base="xsd:string">
    <xsd:annotation>
      <xsd:documentation>Must conform to udunits time duration, eg "20.1 hours"
      </xsd:documentation>
    </xsd:annotation>
  </xsd:restriction>
</xsd:simpleType>
----

A duration type can be one of the following:

an http://www.w3schools.com/schema/schema_dtypes_date.asp[xsd:duration]
type specified in the following form "PnYnMnDTnHnMnS" where:

* P indicates the period (required)
* nY indicates the number of years
* nM indicates the number of months
* nD indicates the number of days
* T indicates the start of a time section (required if you are going to
specify hours, minutes, or seconds)
* nH indicates the number of hours
* nM indicates the number of minutes
* nS indicates the number of seconds +

a valid http://www.unidata.ucar.edu/packages/udunits/[udunits] time
duration string.

Example:

[source,xml]
----
<duration>P5Y2M10DT15H</duration>
<duration>5 days</duration>
----

[[dataSize]]
=== _dataSize_ element

[source,xml]
----
<xsd:element name="dataSize">
  <xsd:complexType>
    <xsd:simpleContent>
    <xsd:extension base="xsd:string">
      <xsd:attribute name="units" type="xsd:string" use="required"/>
    </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>
</xsd:element>
----

A dataSize element is just a number with a units attribute, which should
be "bytes", "Kbytes", "Mbytes", "Gbytes" or "Tbytes".

Example:

[source,xml]
----
<dataSize units="Kbytes">123</dataSize>
----

[[controlledVocabulary]]
=== _controlledVocabulary_ type

[source,xml]
----
<xsd:complexType name="controlledVocabulary">
 <xsd:simpleContent>
  <xsd:extension base="xsd:string">
   <xsd:attribute name="vocabulary" type="xsd:string" />
  </xsd:extension>
 </xsd:simpleContent>
</xsd:complexType>
----

A controlledVocabulary simply adds an optional vocabulary attribute to
the string-valued element, indicating that the value comes from a
restricted list.

Example:

[source,xml]
----
 <name vocabulary="DIF">UCAR/NCAR/CDP</name>
----

[[variablesType]]
=== _variables_ element

[source,xml]
----
<xsd:element name="variables">
  <xsd:complexType>
    <xsd:choice>
      <xsd:element ref="variable" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element ref="variableMap" minOccurs="0"/>
    </xsd:choice>
    <xsd:attribute name="vocabulary" type="variableNameVocabulary" use="optional"/>
    <xsd:attributeGroup ref="XLink"/>
  </xsd:complexType>
</xsd:element>

<xsd:element name="variable">
  <xsd:complexType mixed="true">
    <xsd:attribute name="name" type="xsd:string" use="required"/>
    <xsd:attribute name="vocabulary_name" type="xsd:string" use="optional"/>
    <xsd:attribute name="units" type="xsd:string"/>
  </xsd:complexType>
</xsd:element>

<xsd:element name="variableMap">
  <xsd:complexType>
    <xsd:attributeGroup ref="XLink"/>
  </xsd:complexType>
</xsd:element>
----

A _variables_ element contains a list of variables OR a _variableMap_
element that refers to another document that contains a list of
variables. This element specifies the variables (aka _fields_ or
__parameters__) that are available in the dataset, and associates them
with a standard vocabulary of names, through the _vocabulary_ attribute.
The optional _XLink_ is a reference to an online resource describing the
standard vocabulary.

Each _variable_ element must have a _name_ attribute which contains the
name of variable in the dataset. The optional _vocabulary_name_
attribute contains the variables name from a standard vocabulary
(specified by the _variables_ element). The _units_ attribute contains
the units of the variable in the dataset. The content of the _variable_
element can contain text describing the variable. A _variableMap_
element contains an _XLink_ to _variable_ elements, so that you can
factor these out and refer to them from multiple places.

The main purpose of the _variables_ element is to describe a dataset for
a search service or digital library, for example GCMD requires a list of
dataset "Parameter Valids" from their controlled vocabulary. A client
might want to show those "standard variable names" to a user, since
the names may be more meaningful than the actual variable names.

Examples:

[source,xml]
----
<variables vocabulary="CF-1.0">
  <variable name="wv" vocabulary_name="Wind Speed" units="m/s">Wind Speed @ surface</variable>
  <variable name="wdir" vocabulary_name="Wind Direction" units= "degrees">Wind Direction @ surface</variable>
  <variable name="o3c" vocabulary_name="Ozone Concentration" units="g/g">Ozone Concentration @ surface</variable>
</variables>

<variables vocabulary="GRIB-NCEP" xlink:href="http://www.unidata.ucar.edu//GRIB-NCEPtable2.xml">
  <variableMap xlink:href="../standardQ/Eta.xml" />
</variables>
----

A _variableMap_ should point to an XML document with a top-level
_variables_ element with the THREDDS namespace declared:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<variables xmlns="http://www.unidata.ucar.edu/namespaces/thredds/InvCatalog/v1.0" >
  <variable name="wv" vocabulary_name="Wind Speed" units="m/s"/>
  <variable name="wdir" vocabulary_name="Wind Direction" units= "degrees"/>
  <variable name="o3c" vocabulary_name="Ozone Concentration" units="g/g"/>
  ...
</variables>
----

[[Enumerations]]
== Other Enumerations

The remaining definitions are all enumerations of "well-known" values.
Note that for all of these, any token is a legal value. However,
standard software is likely to understand only the values that are
explicitly listed. We encourage you to use these *_well-known values_*
if possible, and to submit new values to the
mailto:thredds@unidata.ucar.edu[THREDDS mailgroup] for inclusion in
future versions of this schema.

[[dataFormat]]
=== _dataFormat_ enumeration

[source,xml]
----
<!-- DataFormat Types -->
<xsd:simpleType name="dataFormatTypes">
  <xsd:union memberTypes="xsd:token mimeType">
    <xsd:simpleType>
      <xsd:restriction base="xsd:token">
        <xsd:enumeration value="BUFR"/>
        <xsd:enumeration value="ESML"/>
        <xsd:enumeration value="GEMPAK"/>
        <xsd:enumeration value="GINI"/>
        <xsd:enumeration value="GRIB-1"/>
        <xsd:enumeration value="GRIB-2"/>
        <xsd:enumeration value="HDF4"/>
        <xsd:enumeration value="HDF5"/>
        <xsd:enumeration value="McIDAS-AREA"/>
        <xsd:enumeration value="NcML"/>
        <xsd:enumeration value="NetCDF"/>
        <xsd:enumeration value="NetCDF-4"/>
        <xsd:enumeration value="NEXRAD2"/>
        <xsd:enumeration value="NIDS"/>

        <xsd:enumeration value="image/gif"/>
        <xsd:enumeration value="image/jpeg"/>
        <xsd:enumeration value="image/tiff"/>
        <xsd:enumeration value="text/csv"/>
        <xsd:enumeration value="text/html"/>
       <xsd:enumeration value="text/plain"/>
         <xsd:enumeration value="text/tab-separated-values"/>
        <xsd:enumeration value="text/xml"/>
        <xsd:enumeration value="video/mpeg"/>
        <xsd:enumeration value="video/quicktime"/>
        <xsd:enumeration value="video/realtime"/>
      </xsd:restriction>
    </xsd:simpleType>
  </xsd:union>
</xsd:simpleType>

<xsd:simpleType name="mimeType">
  <xsd:restriction base="xsd:token">
    <xsd:annotation>
      <xsd:documentation>any valid mime type
        (see http://www.iana.org/assignments/media-types/)
      </xsd:documentation>
    </xsd:annotation>
  </xsd:restriction>
</xsd:simpleType>
----

These describe the data formats, used in an link:#access[access]
attribute or link:#dataset[dataset] element, when the service is a bulk
transport (like FTP) and the client has to know how to read the
downloaded dataset file.

In addition to the file formats explicitly listed, you can use a
http://www.iana.org/assignments/media-types/[mime type]. We have also
listed ones above that seem likely to be relevent.

You can also use your own scientific file format; send us them and we
will add it to this list (check to see if its a mime type first).

Examples:

[source,xml]
----
<dataFormat>NcML</dataFormat>
<dataFormat>image/gif</dataFormat>
<dataFormat>image/jpeg</dataFormat>
<dataFormat>image/png</dataFormat>
<dataFormat>video/mpeg</dataFormat>
<dataFormat>video/quicktime</dataFormat>
----

[[dateType]]
=== _dataType_ enumeration

[source,xml]
----
<xsd:simpleType name="dataTypes">
  <xsd:union memberTypes="xsd:token">
    <xsd:simpleType>
      <xsd:restriction base="xsd:token">
        <xsd:enumeration value="Grid"/>
        <xsd:enumeration value="Image"/>
        <xsd:enumeration value="Point"/>
        <xsd:enumeration value="Radial"/>
        <xsd:enumeration value="Station"/>
        <xsd:enumeration value="Swath"/>
        <xsd:enumeration value="Trajectory"/>
      </xsd:restriction>
    </xsd:simpleType>
  </xsd:union>
</xsd:simpleType>
----

These are
the <<../../netcdf-java/reference/FeatureDatasets/Overview#,Feature
Types>> of the datasets, which are used by clients to know how to display
the data.

[[dateEnumTypes]]
=== _date_ enumeration

[source,xml]
----
<xsd:simpleType name="dateEnumTypes">
  <xsd:union memberTypes="xsd:token">
    <xsd:simpleType>
      <xsd:restriction base="xsd:token">
        <xsd:enumeration value="created"/>
        <xsd:enumeration value="modified"/>
        <xsd:enumeration value="valid"/>
        <xsd:enumeration value="issued"/>
        <xsd:enumeration value="available"/>
        <xsd:enumeration value="metadataCreated"/>
      </xsd:restriction>
    </xsd:simpleType>
  </xsd:union>
</xsd:simpleType>
----

The date type enumeration defines a basic set of types for a
link:#date[date] element. These values were taken from the Dublin Core
metadata set.

This set of values is not exclusive so other values are allowed.
Alternate values must be strings that do not contain end-of-line
characters or tabs (they must be of the
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#token[xsd:token]
data type).

[[documentationEnumTypes]]
=== _documentation_ enumeration

[source,xml]
----
<xsd:simpleType name="documentationEnumTypes">
 <xsd:union memberTypes="xsd:token">
  <xsd:simpleType>
   <xsd:restriction base="xsd:token">
     <xsd:enumeration value="funding"/>
     <xsd:enumeration value="history"/>
     <xsd:enumeration value="processing_level"/>
     <xsd:enumeration value="rights"/>
     <xsd:enumeration value="summary"/>
   </xsd:restriction>
  </xsd:simpleType>
 </xsd:union>
</xsd:simpleType>
----

The documentation type enumeration defines a basic set of types used by
the link:#documentation[documentation] element.

This set of values is not exclusive so other values are allowed.
Alternate values must be strings that do not contain end-of-line
characters or tabs (they must be of the
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#token[xsd:token]
data type).

[[metadataType]]
=== _metadata_ enumeration

[source,xml]
----
  <xsd:simpleType name="metadataTypeEnum">
    <xsd:union memberTypes="xsd:token">
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="THREDDS"/>
          <xsd:enumeration value="ADN"/>
          <xsd:enumeration value="Aggregation"/>
          <xsd:enumeration value="CatalogGenConfig"/>
          <xsd:enumeration value="DublinCore"/>
          <xsd:enumeration value="DIF"/>
          <xsd:enumeration value="FGDC"/>
          <xsd:enumeration value="LAS"/>
          <xsd:enumeration value="ESG"/>
        <xsd:enumeration value="Other"/>
      </xsd:restriction>
     </xsd:simpleType>
   </xsd:union>
  </xsd:simpleType>
----

The metadata type enumeration defines a basic set of types used by the
link:#metadata[metadata] element.

This set of values is not exclusive so other values are allowed.
Alternate values must be strings that do not contain end-of-line
characters or tabs (they must be of the
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#token[xsd:token]
data type).

[[serviceTypes]]
=== _serviceTypes_ enumeration

[source,xml]
----
<xsd:simpleType name="serviceTypes">
 <xsd:union memberTypes="xsd:token">
  <xsd:simpleType>
   <xsd:restriction base="xsd:token">

    <!-- client/server -->
    <xsd:enumeration value="ADDE"/>
    <xsd:enumeration value="DAP4"/>
    <xsd:enumeration value="DODS"/> <!-- same as OpenDAP -->
    <xsd:enumeration value="OpenDAP"/>
    <xsd:enumeration value="OpenDAPG"/>
    <xsd:enumeration value="NetcdfSubset"/>
    <xsd:enumeration value="CdmRemote"/>
    <xsd:enumeration value="CdmFeature"/>
    <xsd:enumeration value="ncJSON"/>
    <xsd:enumeration value="H5Service"/>

    <!-- bulk transport -->
    <xsd:enumeration value="HTTPServer"/>
    <xsd:enumeration value="FTP"/>
    <xsd:enumeration value="GridFTP"/>
    <xsd:enumeration value="File"/>

    <!-- web services -->
    <xsd:enumeration value="ISO"/>
    <xsd:enumeration value="LAS"/>
    <xsd:enumeration value="LAS"/>
    <xsd:enumeration value="NcML"/>
    <xsd:enumeration value="UDDC"/>
    <xsd:enumeration value="WCS"/>
    <xsd:enumeration value="WMS"/>
    <xsd:enumeration value="WSDL"/>

    <!--offline -->
    <xsd:enumeration value="WebForm"/>

    <!-- THREDDS -->
    <xsd:enumeration value="Catalog"/>
    <xsd:enumeration value="Compound"/>
    <xsd:enumeration value="Resolver"/>
    <xsd:enumeration value="THREDDS"/>
   </xsd:restriction>
  </xsd:simpleType>
 </xsd:union>
</xsd:simpleType>
----

These are the known service types, used in a link:#service[service]
element, that indicate how to access a dataset. A serviceType is
similar, but not generally the same as the
http://www.iana.org/assignments/uri-schemes[scheme] of a URI, like
__http:, ftp:, file:__, etc. In general, the combination of the
*serviceType* and the link:#dataFormatType[dataFormat] is intended to be
sufficient for a client to access and read the dataset. Additional
information can be encoded in service properties.

The *OpenDAP* and *ADDE* service types correspond to the
http://www.opendap.org[OpenDAP] and
http://www.ssec.wisc.edu/mcidas/doc/learn_guide/current/adde.html[ADDE]
data access protocols. These are client/server protocols that specify
both the access (or transport) protocol and the data model, so no
seperate dataFormat attribute is needed. DODS is a synonym for
**OpenDAP**; *OpenDAP-G* corresponds to OpenDAP over GridFTP.

The next set of service types are all bulk transfer protocols, and you
need to also specify the link:#dataFormatType[dataFormat] for datasets
that use these. *FTP* is the well-known File Transfer Protocol, and
http://www.globus.org/grid_software/data/gridftp.php[*GridFTP*] is a
variant of that used by the Globus Data Grid. The *File* service is for
local files, used for local catalogs or in situations like DODS
Aggregation Server configuration. A _File_ dataset is not readable by
remote clients. *HTTPServer* should be used when your file is being
served by an HTTP (Web) Server. This is used for bulk transfer just like
FTP, and also can be used by the
http://www.unidata.ucar.edu/packages/netcdf-java/[Java-NetCDF library]
to access NetCDF files remotely (in that case just make sure that the
dataset has dataFormatType NetCDF or NcML).

The *LAS* service type is for connection to Live Access Servers.
**WMS**, *WFS* and *WCS* are for the __Web Map, Feature__, and
__Coverage Servers__, respectively, from the
http://www.opengis.org/[OpenGIS Consortium]. These are still
experimental servers, at least for THREDDS. *WSDL* corresponds to a
server using the http://www.w3.org/TR/wsdl[Web Services Description
Language] to specify its data services. We do not yet have an example of
that within THREDDS.

The *WebForm* service indicate that the dataset URL will take you to an
HTML page where you can presumably order the data in some way, to be
delivered later. Its still a good idea to specify the dataset
dataFormatType.

The last set of service types are THREDDS defined types. The *Catalog*
and *Resolver* types return XML documents over HTTP. These are generally
handled internally by THREDDS. A
link:#compoundService[Compound Service] just indicates that the service is composed of other services.

[[variableNameVocabulary]]
=== _variableNameVocabulary_ enumerations

[source,xml]
----
<xsd:simpleType name="variableNameVocabulary">
  <xsd:union memberTypes="xsd:token">
    <xsd:simpleType>
      <xsd:restriction base="xsd:token">
        <xsd:enumeration value="CF-1.0"/>
        <xsd:enumeration value="DIF"/>
        <xsd:enumeration value="GRIB-1"/>
        <xsd:enumeration value="GRIB-2"/>
      </xsd:restriction>
    </xsd:simpleType>
  </xsd:union>
</xsd:simpleType>
----

These are the known vocabularies for standard variable names, used in
the link:#variables[variables] element. *CF* refers to the
http://cfconventions.org[Climate and Forecast Conventions] metadata
conventions for netCDF; they have a list of
http://cfconventions.org/standard-names.html[standard variable names].
*DIF* is http://gcmd.gsfc.nasa.gov/User/difguide/difman.html[Directory
Interchange Format] from NASA’s Global Change Master Directory, which
has a controlled variable
http://gcmd.gsfc.nasa.gov/User/difguide/parameters.html[classification
scheme]. The World Meteorological Organization’s
http://dss.ucar.edu/docs/formats/grib/gribdoc/[GRIB (version 1)] data
file format defines a set of standard parameters.

You can also use another vocabulary name; send it to us and we will add
it to this list.

[[Dataset_Access_Methods]]
== Dataset Access Methods

There are two ways a dataset’s access methods can be specified:

1.  A _dataset_ element may include a *_urlPath_* attribute.
The value of the _urlPath_ attribute along with the dataset *_default service_* specify one or more access methods.
2.  A _dataset_ element may include child *_access elements_*.
Each _access_ element defines one or more access methods.
The values of the _access_ element’s _urlPath_ and _serviceName_ attributes specify one or more access methods.
If the _access_ element does not include a _serviceName_ attribute, the _dataset_ default service is used.

(*) Multiple access methods are defined whenever the service element is a compound service. More on this in the
link:#compound[Access Methods and Compound Services] section below. +

=== Dataset Default Service

A dataset may have a *_serviceName attribute_* or *_serviceName element_* directly in it.
If not, then it may *_inherit_* a serviceName from a parent dataset.

==== Examples

1. A _dataset_ element has a _urlPath_ attribute and inherits a
_serviceName_ element from a parent/ancestor dataset. This is probably
the most common case as many catalogs will contain datasets that all
refer to one service.
+
[source,xml]
----
<dataset name="collection of data">
  <metadata inherited="true">
    <serviceName>myservice</serviceName>
  </metadata>
  <dataset name="my dataset" urlPath="myData.nc" />
  <dataset name="our dataset" urlPath="ourData.nc" />
  <dataset name="their dataset" urlPath="theirData.nc" />
  ...
</dataset>
----

2. A _dataset_ element has a _urlPath_ attribute and directly contains a _serviceName_ element or attribute.
+
[source,xml]
----
<dataset name="my dataset" urlPath="myData.nc">
  <serviceName>myservice</serviceName>
</dataset>

<dataset name="my dataset" urlPath="myData.nc" serviceName="myservice">
----

3. A _dataset_ element contains a child _access_ element. Example:
+
[source,xml]
----
<dataset name="my dataset">
  <access serviceName="myservice" urlPath="myData.nc" />
</dataset>
----


[[compound]]
=== Access Methods and Compound Services

Any  _service_ element of type Compound used in the construction of access methods results
in one access method for each nested service.

For example:

[source,xml]
----
<service name="all" serviceType="Compound" base="" >
  <service name="odap" serviceType="OPENDAP" base="/thredds/dodsC/" />
  <service name="wcs" serviceType="WCS" base="/thredds/wcs/" />
</service>
<dataset name="cool data" urlPath="cool/data.nc">
  <serviceName>all</serviceName>
</dataset>
----

results in two access methods for "cool data"; one using the "odap"
_service_ element and the other using the "wcs" _service_ element,
both using the _urlPath_ attribute value "cool/data.nc"

[[constructingURLs]]
=== Constructing URLs

A dataset access URL is constructed by concatenating the service base
URL with the access urlPath. If the service has a suffix attribute, that
is then appended:

   URL = service.base + access.urlPath + service.suffix

Note: These operations are straight string concatenations, a slash
("/") is not automatically added. If a slash is needed between the
base and urlPath, remember to include a trailing slash on the value of
the service@base attribute.

Clients have access to each of these elements and may make use of the
URL in protocol-specific ways. For example the OpenDAP (DODS) protocol
appends _dds, das, dods_ etc to make the actual calls to the OpenDAP
server.

When a service base is a
http://www.webreference.com/html/tutorial2/3.html[relative URL], it is
resolved against the catalog base URL. For example if the catalog base
URL is _\http://thredds.ucar.edu/thredds/dodsC/catalog.xml_, and a
service base is _airtemp/_, then the resolved base is
_\http://thredds.ucar.edu/thredds/dodsC/airtemp/_. Note that if the
service base is _/airtemp/_, the resolved URL is
_\http://thredds.ucar.edu/thredds/airtemp/_.

[[datasetClassification]]
== Dataset Classification

THREDDS *_Dataset Inventory Catalogs_* organize and describe collections
of data. A catalog can be thought of as a logical directory of data
resources available via the Internet. A dataset may be a *_direct
dataset_* (describes how to directly access data over the Internet), a
*_collection dataset_* (contains other datasets) or a *_dynamic
dataset_* (content is generated by a call to a server).

[[directDataset]]
A *_direct access dataset_* has an access URL and a *_service type_* (like
__FTP__, __DODS__, _WMS_, etc.) that allows a THREDDS-enabled
application to directly access its data, using the specified service’s
protocol. It is represented simply by a *<dataset>* element.

A *_collection dataset_* has nested *<dataset>* elements. We distinguish two types:

* A *_heterogeneous collection dataset_* may have arbitrarily-deep
nested datasets, and there are no constraints on how the datasets are
related.
* A *_coherent collection dataset_* contains nested datasets which must
be direct and coherently related. A coherent dataset should have a
_collectionType_ attribute that describes the relationship of its nested
datasets.

A *_dynamic dataset_* has an access URL and a service type _Catalog_, or _Resolver_.
Its contents are generated dynamically by making a call to a server, and describe datasets that are
constantly changing, and/or are too large to list exhaustively.

* A *_query dataset_* is a dynamic dataset with service type
__Catalog__. Dereferencing the URL returns another catalog, whose
contents can be thought of as 1) the contents of the query dataset, and
2) the result of the query.
* A *_resolver dataset_* is a kind of query dataset, with service type
__Resolver__. It returns a catalog which must contain either a direct
dataset, or a coherent collection dataset. It is typically used to
implement a _*virtual*_ dataset like "latest model run" or "latest
measurement" on a real time dataset, where the actual URL must be
generated when the user requests it.

A query dataset looks a lot like a link:#catalogRef[catalogRef], since
you dereference a URL and get a catalog back. However, a catalogRef is
cacheable, but a query dataset is inherently dynamic, so is not cacheable.

[[webResources]]
== Datasets as Web Resources

Its important to distinguish a THREDDS dataset from its access URL. A
dataset can have multiple ways of being accessed, and so have multiple
access URLs. But even in the simple case that a dataset has one access
URL, the dataset potentially contains metadata that is not stored with
the data pointed to by its access URL. In order to use the full power of
THREDDS, you must work with the full dataset object, not just with its
access URL.

One way to reference the dataset as a web resource is to use *_catalog.xml#datasetId_*,
where _catalogURL_ is the URL of a THREDDS catalog, and _datasetId_ is the ID of a dataset inside of that catalog.
Example:

----
http://server:8080/thredds/catalog/grib.v5/gfs_2p5deg/catalog.xml#grib.v5/gfs_2p5deg/TwoD
----

The reference implementation of THREDDS datasets is the link:../../netcdf-java[netCDF-Java library],
which accepts dataset URLS of the form *_thredds:catalog.xml#dataset_id_*,
where the _thredds:_ prefix ensures that the URL is understood as a THREDDS catalog and dataset.

In the context of a web browser, the dataset URL is *_catalog.html?dataset=datasetId_*, for example

----
http://localhost:8081/thredds/catalog/GFS_CONUS_80km/catalog.html?dataset=GFS_CONUS_80km/Best
----

This URL, when sent to a THREDDS Data Server, shows the metadata for the dataset with ID _GFS_CONUS_80km/Best_
in the catalog _\http://localhost:8081/thredds/catalog/GFS_CONUS_80km/catalog.html_.

'''''

image:../thread.png[THREDDS]This document was last updated Ocober 2015.
Send comments to mailto:support-thredds@unidata.ucar.edu[THREDDS support].
