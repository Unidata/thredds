<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.vets.ucar.edu/luca/netcdf/netcdf.xsd.html -->
<HTML>
<HEAD>
  <META http-equiv=Content-Type content="text/html; charset=windows-1252">
  <title>NcML Schema</title>
  <link href="../cdm.css" rel="stylesheet" type="text/css"/>

</HEAD>
<BODY>
<h1 align=left>Annotated Schema for NcML</h1>

<p align=left><em>for version 4.4+ of the Netcdf-Java/CDM library</em></p>
<hr>
<p align=left>An <em><strong>NcML document</strong></em> is an XML document (aka an <em>instance</em> document) whose contents are described and constrained by
  <em><strong>NcML Schema-2.2</strong></em>. NcML Schema-2.2 combines the earlier <em>NcML core schema</em> which is an XML description of the netCDF-Java / CDM
  data model, with the earlier <em>NcML dataset schema</em>, which allows you to define, redefine, aggregate, and subset existing netCDF
  files.</p>

<p align=left>An NcML document represents a generic netCDF dataset, i.e. a container for data conforming to the netCDF data model. For instance, it might
  represent an existing netCDF file, a netCDF file not yet written, a GRIB file read through the netCDF-Java library, a subset of a netCDF file, an aggregation
  of netCDF files, or a self-contained dataset (i.e. all the data is included in the NcML document and there is no seperate netCDF file holding the data). An
  NcML document therefore should not necessarily be thought of as a physical netCDF file, but rather the "public interface" to a set of data conforming to the
  netCDF data model. </p>

<p align=left><em><strong>NcML Schema-2.2</strong></em> is written in the <a href="http://www.w3.org/XML/Schema">W3C XML Schema</a> language, and essentially
  represents the netCDF-Java / CDM data model, which schematically looks like this in
  <a href="../CDM/CDM-UML.png">UML</a>: </p>

<p align=left>&nbsp;</p>

<p align=left><img src="CDM-UML.png" width="627" height="598" alt=""></p>
<blockquote>
  <blockquote>
    <blockquote>
      <blockquote>
        <blockquote>
          <p align="left"><strong> CDM UML</strong></p>
        </blockquote>
      </blockquote>
      <p align="left">&nbsp;</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2 align=left>Annotated Schema </h2>

<p align=left>Aggregation specific elements are <font color="#990000">listed in red.</font> <font color="#990000">The <em>forecastModelRunCollection,
  forecastModelRunSingleCollection, joinExisting </em>and<em> joinNew</em> aggregation types are called <strong><em>outer aggregations</em></strong> because
  they work on the outer (first) dimension.</font></p>

<h3 align=left>schema Element <B><FONT color=#ff0000> </FONT></B></h3>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;xsd:schema targetNamespace=&quot;http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2&quot;<br>  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;<br>  xmlns=&quot;http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2&quot;<br>  elementFormDefault=&quot;qualified&quot;&gt;
</pre>
<h3><B>netcdf Element</B></h3>

<P>The element <I><strong>netcdf</strong></I> is the root tag of the
  NcML instance document, and is said to define a <em><strong>NetCDF dataset</strong></em>.</P>
<pre>&lt;!-- XML encoding of Netcdf container object --&gt;
&lt;xsd:element name=&quot;netcdf&quot;&gt;<br>  &lt;xsd:complexType&gt;<br>    &lt;xsd:sequence&gt;

 (1)  &lt;xsd:choice minOccurs=&quot;0&quot;&gt;<br>        &lt;xsd:element name=&quot;readMetadata&quot;/&gt;<br>        &lt;xsd:element name=&quot;explicit&quot;/&gt;<br>      &lt;/xsd:choice&gt;

 (2)  &lt;xsd:element name=&quot;iospParam&quot; minOccurs=&quot;0&quot; /&gt;
<br> (3)  &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;<br>        &lt;xsd:element ref=&quot;group&quot;/&gt;
        &lt;xsd:element ref=&quot;dimension&quot;/&gt;<br>        &lt;xsd:element ref=&quot;variable&quot;/&gt;<br>        &lt;xsd:element ref=&quot;attribute&quot;/&gt;<br>        &lt;xsd:element ref=&quot;remove&quot;/&gt;<br>      &lt;/xsd:choice&gt;
<br> <font color="#AA0000">(4)  &lt;xsd:element ref=&quot;aggregation&quot; minOccurs=&quot;0&quot;/&gt;</font><br>    &lt;/xsd:sequence&gt;
 (5)&lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:anyURI&quot;/&gt;
 (6)&lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot;/&gt;
 (7)&lt;xsd:attribute name=&quot;title&quot; type=&quot;xsd:string&quot;/&gt;
 (8)&lt;xsd:attribute name=&quot;enhance&quot; type=&quot;xsd:string&quot;/&gt;
 (9)&lt;xsd:attribute name=&quot;addRecords&quot; type=&quot;xsd:boolean&quot;/&gt;

(10)&lt;xsd:attribute name=&quot;iosp&quot; type=&quot;xsd:string&quot;/&gt;<br>    &lt;xsd:attribute name=&quot;iospParam&quot; type=&quot;xsd:string&quot;/&gt;
    &lt;xsd:attribute name=&quot;bufferSize&quot; type=&quot;xsd:int&quot;/&gt;

  <font color="#AA0000">&lt;!-- for netcdf elements nested inside of <a href="#aggregation">aggregation</a> elements --&gt;
(11)&lt;xsd:attribute name=&quot;ncoords&quot; type=&quot;xsd:string&quot;/&gt;
(12)&lt;xsd:attribute name=&quot;coordValue&quot; type=&quot;xsd:string&quot;/&gt;
(13)&lt;xsd:attribute name=&quot;section&quot; type=&quot;xsd:string&quot;/&gt;<br>
  </font>&lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;


</pre>
<OL>
  <LI>A <em><strong>readMetadata</strong></em> (default) or an <em><strong>explicit</strong></em> element comes first. The
    <em><strong>readMetadata</strong></em> element indicates that all the metadata from the referenced dataset will be read in. The
  <em><strong>explicit</strong></em> element indicates that only the metadata explictly declared in the NcML file will be used.  
  <LI>An optional iospParam element. 
  The NcML inside this element is passed directly to the IOSP. If an <strong>iospParam</strong> attribute is used, the attribute is used instead.
  <LI>The <I><strong>netcdf</strong></I> element may contain any number
    (including 0) of elements <I><strong>group, variable</strong></I>, <I><strong>dimension</strong></I>, <I>or<strong> attribute</strong></I> that can appear
    in any order. If you use readMetadata, you can remove specific elements with the <em><strong>remove</strong></em> element.
  <LI><font color="#990000">An aggregation element is used to logically join multiple netcdf datasets into a single dataset.
  </font>
  <LI>The optional <I><strong>location</strong></I> attribute provides a reference to another netCDF dataset, called the <em><strong>referenced dataset</strong></em>.
    The location can be an absolute URL (eg <strong>http://server/myfile</strong>, or <strong>file:/usr/local/data/mine.nc</strong>) or a URL reletive to the
    NcML location (eg <strong>subdir/mydata.nc</strong>). The referenced dataset contains the variable data that is not explicitly specified in the NcML
    document itself. If the location is missing and the data is not defined in <strong>values</strong> elements, then an empty file is written similar to the
    way CDL files are written by ncgen.
  <LI>The optional <I><strong>id</strong></I> attribute is meant to provide a
    way to uniquely identify (relative to the application context) the NetCDF dataset. It is important to understand that the <I>id</I> attribute refers to
    the NetCDF dataset defined by the XML instance document, NOT the referenced dataset if there is one.
  <LI>The optional <I><strong>title</strong></I> attribute provides a way to add a human readable title to the netCDF dataset.
  <LI>The optional <em><strong>enhance<a name="enhance"></a></strong></em> attribute indicates whether the referenced dataset is opened in enhanced mode, and
    can be set to <em>All, AllDefer, ScaleMissing, ScaleMissingDefer, CoordSystems, or None </em>(case insensitive). For backwards compatibility, a value of
    <em>true</em> means <em>All</em>. Default is <em>None</em>. See
    <a href="http://www.unidata.ucar.edu/software/netcdf-java/tutorial/NetcdfDataset.html#enhance">NetcdfDataset.EnhanceMode</a>.
  <LI>The optional <em><strong>addRecords</strong></em> attribute is used only when the referenced datasets is a netCDF-3 file. If true (default false) then a
    Structure named <em><strong>record</strong></em> is added, containing the record (unlimited) variables. This allows one to read efficiently along the
    unlimited dimension.
  <LI>These 3 parameters control how the referenced dataset is opened by the IOServiceProvider. If <strong>iosp</strong> is specified, its value must be a fully
    qualified class name of an <strong><a href="http://www.unidata.ucar.edu/software/netcdf-java/tutorial/IOSPoverview.html">IOServiceProvider</a></strong>
    class that knows how to open the file specified by <strong>location</strong>. The optional <strong>iospParam</strong> is passed to the IOSP through the
    <strong>IOServiceProvider</strong>.setSpecial() method. The optional <strong>bufferSize</strong> tells the IOSP how many bytes to use for buffering the file
    data.
  <LI><font color="#990000">The optional <strong><em>ncoords</em></strong> attribute is used for <strong>joinExisting</strong> aggregation datasets to indicate
    the number of coordinates that come from the dataset. This is used to avoid having to open each dataset when starting. </font>
  <LI><font color="#990000"> The <strong><em>coordValue</em></strong> attribute is used for <strong>joinExisting</strong> or <strong>joinNew</strong>
    aggregations to assign a coordinate value(s) to the dataset. A <strong>joinNew</strong> aggregation always has exactly one coordinate value. A <strong>joinExisting</strong>
    may have multiple values, in which case, blanks and/or commas are used to delineate them, so you cannot use those characters in your coordinate
    values.</font>
  <LI><font color="#990000">The <strong>section</strong> attribute is used only for tiled aggregations, and describes which section of the entire dataset this
  dataset represents. The section value follows the ucar.ma2.Section <em>section spec</em> (see javadocs), eg &quot;(1:20,:,3)&quot;, parenthesis optional</font>
</OL>
<p>An example: </p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;netcdf xmlns=&quot;http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2&quot; 
		  location=&quot;C:/dev/github/thredds/cdm/src/test/data/testWrite.nc&quot;&gt;<br>  &lt;dimension name=&quot;lat&quot; length=&quot;64&quot; /&gt;<br>  &lt;dimension name=&quot;lon&quot; length=&quot;128&quot; /&gt;<br>  &lt;dimension name=&quot;names_len&quot; length=&quot;80&quot; /&gt;<br>  &lt;dimension name=&quot;names&quot; length=&quot;3&quot; /&gt;<br>
  &lt;variable name=&quot;names&quot; type=&quot;char&quot; shape=&quot;names names_len&quot; /&gt;<br> <br>  &lt;variable name=&quot;temperature&quot; shape=&quot;lat lon&quot; type=&quot;double&quot;&gt;<br>    &lt;attribute name=&quot;units&quot; value=&quot;K&quot; /&gt;<br>    &lt;attribute name=&quot;scale&quot; type=&quot;int&quot; value=&quot;1 2 3&quot; /&gt;<br>  &lt;/variable&gt;<br><br>&lt;/netcdf&gt;</pre>
<h3><B>group Element</B></h3>

<p> A <I><strong>group</strong></I> element represents a netCDF group, a container for <I><strong>variable</strong></I>, <I><strong>dimension</strong></I>,
  <I><strong>attribute</strong></I>, or other <I><strong>group </strong></I>elements. </p>
<pre>  
&lt;xsd:element name=&quot;group&quot;&gt;
  &lt;xsd:complexType&gt;
(1)&lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
     &lt;xsd:element ref=&quot;enumTypedef&quot;/&gt;
     &lt;xsd:element ref=&quot;dimension&quot;/&gt;
     &lt;xsd:element ref=&quot;variable&quot;/&gt;
     &lt;xsd:element ref=&quot;attribute&quot;/&gt;
     &lt;xsd:element ref=&quot;group&quot;/&gt;
     &lt;xsd:element ref=&quot;remove&quot;/&gt;
   &lt;/xsd:choice&gt;

(2)&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;
(3)&lt;xsd:attribute name=&quot;orgName&quot; type=&quot;xsd:string&quot;/&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</pre>
<OL>
  <LI>The <I><strong>group</strong></I> element may contain any number (including 0) of elements <I><strong>group, variable</strong></I>,
    <I><strong>dimension</strong></I>, <I>or<strong> attribute</strong></I> that can appear in any order. You can also mix in <em><strong>remove</strong></em>
    elements to remove elements coming from the referenced dataset.
  <LI>The mandatory <I><strong>name</strong></I> attribute must be unique among groups within its containing <em><strong>group</strong></em> or <strong><em>netcdf</em></strong>
    element.
  <LI>The optional attribute <em><strong>orgName</strong></em> is used when renaming a group.</LI>
</OL>
<h3><B>dimension Element</B></h3>

<p> The <I><strong>dimension</strong></I> element represents a netCDF dimension, i.e. a named index of
  specified length.</p>
<pre>  &lt;!-- XML encoding of Dimension object --&gt;
  &lt;xsd:element name=&quot;dimension&quot;&gt;<br>    &lt;xsd:complexType&gt;<br>(1)   &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;<br>(2)   &lt;xsd:attribute name=&quot;length&quot; type=&quot;xsd:string&quot;/&gt;<br>(3)   &lt;xsd:attribute name=&quot;isUnlimited&quot; type=&quot;xsd:boolean&quot; default=&quot;false&quot;/&gt;<br>(4)   &lt;xsd:attribute name=&quot;isVariableLength&quot; type=&quot;xsd:boolean&quot; default=&quot;false&quot;/&gt;<br>(5)   &lt;xsd:attribute name=&quot;isShared&quot; type=&quot;xsd:boolean&quot; default=&quot;true&quot;/&gt;<br>(6)   &lt;xsd:attribute name=&quot;orgName&quot; type=&quot;xsd:string&quot;/&gt;<br>    &lt;/xsd:complexType&gt;<br>  &lt;/xsd:element&gt;</pre>

<OL>
  <LI>The mandatory <I><strong>name</strong></I> attribute must be unique among dimensions within its containing <em><strong>group</strong></em> or <strong><em>netcdf</em></strong>
    element.
  <LI>The mandatory attribute <I><strong>length</strong> </I>expresses the
    cardinality (number of points) associated with the dimension. Its value can be
    any non negative integer including 0 (since the unlimited dimension in a
    netCDF file may have length 0, corresponding to 0 records).
  A variable length dimension should be given length=&quot;*&quot;.<LI>The attribute <I><strong>isUnlimited</strong> </I>is <em>true</em> only if the dimension can grow (a.k.a the record dimension in NetCDF-3 files), and <em>false</em>
    when the length is fixed at file creation.
  </LI>
  <LI>The attribute <em><strong>isVariableLength</strong></em> is used for <em>variable length</em> data types, where the length is not part of the metadata..
  </LI>
  <LI>The attribute <em><strong>isShared</strong></em> is <em>true</em> for shared dimensions, and <em>false</em> when the dimension is private to the variable.
  </LI>
  <LI>The optional attribute <em><strong>orgName</strong></em> is used when renaming a dimension.</LI>
</OL>
<h3><B>variable Element </B></h3>

<P> A <em><strong>variable</strong></em> element represents a netCDF variable, i.e. a scalar or multidimensional array of
  specified type indexed by 0 or more dimensions.</P>
<pre>  &lt;xsd:element name=&quot;variable&quot;&gt;<br>    &lt;xsd:complexType&gt;<br>      &lt;xsd:sequence&gt;<br>(1)     &lt;xsd:element ref=&quot;attribute&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br>(2)     &lt;xsd:element ref=&quot;values&quot; minOccurs=&quot;0&quot;/&gt;<br>(3)     &lt;xsd:element ref=&quot;variable&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br>(4)     &lt;xsd:element ref=&quot;logicalSection&quot; minOccurs=&quot;0&quot;/&gt;<br>(5)     &lt;xsd:element ref=&quot;logicalSlice&quot; minOccurs=&quot;0&quot;/&gt;<br>(6)     &lt;xsd:element ref=&quot;remove&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;<br>      &lt;/xsd:sequence&gt;
<br>(7)   &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:token&quot; use=&quot;required&quot; /&gt;<br>(8)   &lt;xsd:attribute name=&quot;type&quot; type=&quot;DataType&quot; use=&quot;required&quot; /&gt;<br>(9)   &lt;xsd:attribute name=&quot;typedef&quot; type=&quot;xsd:string&quot;/&gt;<br>(10)  &lt;xsd:attribute name=&quot;shape&quot; type=&quot;xsd:token&quot; /&gt;<br>(11)  &lt;xsd:attribute name=&quot;orgName&quot; type=&quot;xsd:string&quot;/&gt;<br>    &lt;/xsd:complexType&gt;<br>  &lt;/xsd:element&gt;</pre>
<OL>
  <LI>A <I><strong>variable</strong></I> element may contain 0 or more <I><strong>attribute</strong></I> elements,
  <LI>The optional<I> <strong>values</strong></I> element is used
    to specify the data values of the variable. The values must be listed compatibly with the size and shape of the variable (slowest varying dimension first).
    If not specified, the data values are taken from the variable of the same name in the referenced dataset.
    Values are the &quot;raw values&quot;, and will have scale.offset/missing applied to them if those attributes are present.
  <LI>A variable of data type <em><strong>structure</strong></em> may have nested variable elements within it.
  <LI>Create a logical section of this variable.
  <LI>Create a logical slice of this variable, where one of the dimensions is set to a constant.
  <LI>You can remove attributes from the underlying variable.
  <LI>The mandatory <I><strong>name</strong></I> attribute must be unique among variables within its containing <em><strong>group, variable, </strong>or
  </em><strong><em>netcdf</em></strong> element.
  <LI>The <I><strong>type</strong></I> attribute is one of the enumerated <a href="#DataType">DataTypes</a>.
  <LI>The typedef is the name of an enumerated Typedef. Can be used only for <strong><em>type=enum1, enum2 </em></strong>or<strong><em> enum4</em></strong>.  
  <LI>The <em><strong>shape</strong></em> attribute lists the names of the dimensions the variable depends on. For a scalar variable, the list will be empty.
    The
    dimension names must be ordered with the slowest varying dimension first (same as in the CDL description).
    Anonymous dimensions are specified with just the integer length. For backwards compatibility, scalar variables may omit this attribute, although this is
    deprecated.
  <LI>The optional attribute <em><strong>orgName</strong></em> is used when renaming a variable. .
</OL>
<h3><B>values Element </B></h3>

<P> A <em><strong>values</strong></em> element specifies the data values of a variable, either by listing them for example: <strong>&lt;values&gt;-109.0 -107.0
  -115.0 93.923230&lt;/values&gt;</strong> or by specifying a start and increment, for example: <strong>&lt;values start=&quot;-109.5&quot; increment=&quot;2.0&quot;
  /&gt;</strong>. For a multi-dimensional variable, the values must be listed compatibly with the size and shape of the variable (slowest varying dimension
  first). </P>
<pre>  &lt;xsd:element name=&quot;values&quot;&gt;<br>    &lt;xsd:complexType mixed=&quot;true&quot;&gt;<br> (1)  &lt;xsd:attribute name=&quot;start&quot; type=&quot;xsd:float&quot;/&gt;<br>      &lt;xsd:attribute name=&quot;increment&quot; type=&quot;xsd:float&quot;/&gt;<br>      &lt;xsd:attribute name=&quot;npts&quot; type=&quot;xsd:int&quot;/&gt;<br> (2)  &lt;xsd:attribute name=&quot;separator&quot; type=&quot;xsd:string&quot; /&gt;<br> (3)  &lt;xsd:attribute name=&quot;fromAttribute&quot; type=&quot;xsd:string&quot;/&gt;<br>    &lt;/xsd:complexType&gt;<br>  &lt;/xsd:element&gt;</pre>
<OL>
  <LI>The values can be specified with a <em><strong>start</strong></em> and <em><strong>increment</strong></em> attributes, if they are numeric and evenly
    spaced. You can enter these as integers or floating point numbers, and they will be converted to the data type of the variable. The number of points will be
    taken from the shape of the variable. (For backwards compatibility, an <em><strong>npts</strong></em> attribute is allowed, although this is deprecated and
    ignored).
  <LI>By default, the list of values are separated by whitespace but a different token can be specified using the <em><strong>separator</strong></em> attribute.
    This is useful if you are entering String values, e.g. &lt;values separator=&quot;*&quot;&gt;My dog*has*fleas&lt;/values&gt; defines three Strings.
  </LI>
  <LI>The values can be specified from a global or variable attribute. To specify a global attribute, use <em><strong>@gattname</strong></em>. For a variable
    attibute use <em><strong>varName@attName</strong></em>. The data type and the shape of the variable must agree with the attribute.
  </LI>
</OL>
<h3><B>attribute Element </B></h3>

<P> The
  <I><strong>attribute</strong></I> elements represents a netCDF attribute, i.e. a name-value pair of
  specified type. Its value may be specified in the <em><strong>value</strong></em> attribute or in the element content<strong>. </strong></P>
<pre>  &lt;xsd:element name=&quot;attribute&quot;&gt;<br>    &lt;xsd:complexType mixed=&quot;true&quot;&gt;<br>(1)   &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;<br>(2)   &lt;xsd:attribute name=&quot;type&quot; type=&quot;DataType&quot; default=&quot;String&quot;/&gt;<br>(3)   &lt;xsd:attribute name=&quot;value&quot; type=&quot;xsd:string&quot; /&gt;<br>(4)   &lt;xsd:attribute name=&quot;separator&quot; type=&quot;xsd:string&quot; /&gt;<br>(5)   &lt;xsd:attribute name=&quot;orgName&quot; type=&quot;xsd:string&quot;/&gt;<br>(6)   &lt;xsd:attribute name=&quot;isUnsigned&quot; type=&quot;xsd:boolean&quot;/&gt;<br>    &lt;/xsd:complexType&gt;<br>  &lt;/xsd:element&gt;</pre>
<OL>
  <LI>The mandatory <I><strong>name</strong></I> attribute must be unique among attributes within its containing <em><strong>group, variable, </strong></em>or
    <strong><em>netcdf</em></strong> element.
  <LI>The <I><strong>type</strong></I> attribute may be <strong>String, byte, short, int, long, float, double</strong><a href="#DataType"></a>.
    If not specified, it defaults to a String.
  <LI>The <I>value </I>attribute contains the actual data of
    the <I>attribute</I> element. In the most common case of single-valued
    attributes, a single number or string will be listed (as in value="3.0"),
    while in the less frequent case of multi-valued attributes, all the numbers
    will be listed and separated by a blank or optionally some other character (as
    in value="3.0 4.0 5.0"). Values can also be specified in the element content:
  <pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;netcdf xmlns=&quot;http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2&quot;&gt;<br>  &lt;attribute name=&quot;actual_range&quot; type=&quot;int&quot; value=&quot;1 2&quot; /&gt;<br>  &lt;attribute name=&quot;factual_range&quot; type=&quot;int&quot;&gt;1 2&lt;/attribute&gt;<br>&lt;/netcdf&gt;
</pre>
  <LI>By default, if the attribute has type String, the entire value is taken as the attribute value, and if it has type other than String, then the list of
    values are separated by whitespace. A different token seperator can be specified using the <em><strong>separator</strong></em> attribute.
  </LI>
  <LI>The optional attribute <em><strong>orgName</strong></em> is used when renaming an existing attribute.</LI>
  <LI>The attribute's values may be unsigned (if <em>byte, short, int </em>or<em> long</em>). By default, they are signed.</LI>
</OL>
<h3><B>DataType<a name="DataType"></a> Type </B></h3>

<P> The DataType Type is an enumerated list of the
  data types allowed for NcML <I>Variable</I> objects. </P>
<pre> &lt;xsd:simpleType name=&quot;DataType&quot;&gt;<br>    &lt;xsd:restriction base=&quot;xsd:token&quot;&gt;<br>      &lt;xsd:enumeration value=&quot;byte&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;char&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;short&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;int&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;long&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;float&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;double&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;String&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;string&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;Structure&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;Sequence&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;opaque&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;enum1&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;enum2&quot;/&gt;<br>      &lt;xsd:enumeration value=&quot;enum4&quot;/&gt;<br>    &lt;/xsd:restriction&gt;<br>  &lt;/xsd:simpleType&gt;</pre>
<ul>
  <li>Unsigned integer types (byte, short, int) are indicated with an <em>_Unsigned = &quot;true</em>&quot; attribute on the Variable.</li>
  <li>A Variable with type enum1. enum2 or enum4 will refer to a <B>enumTypedef</B> object. Call Variable.getEnumTypedef().</li>
</ul>
<h3><B>enumTypedef <a name="enumTypedef"></a>Element </B></h3>
<P> The enumTypedef element defines an enumeration.</P>
<pre> &lt;xsd:element name=&quot;enumTypedef&quot;&gt;<br>   &lt;xsd:complexType mixed=&quot;true&quot;&gt;<br>      &lt;xsd:sequence&gt;<br>        &lt;xsd:element name=&quot;map&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;&gt;<br>          &lt;xsd:complexType mixed=&quot;true&quot;&gt;<br>            &lt;xsd:attribute name=&quot;value&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;<br>          &lt;/xsd:complexType&gt;<br>        &lt;/xsd:element&gt;<br>      &lt;/xsd:sequence&gt;<br>      &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;<br>      &lt;xsd:attribute name=&quot;type&quot; type=&quot;DataType&quot; default=&quot;enum1&quot;/&gt;<br>    &lt;/xsd:complexType&gt;<br>  &lt;/xsd:element&gt;</pre>
<p>Example:</p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;netcdf xmlns=&quot;http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2&quot; location=&quot;Q:/cdmUnitTest/formats/netcdf4/tst/test_enum_type.nc&quot;&gt;<br>  &lt;enumTypedef name=&quot;cloud_class_t&quot; type=&quot;enum1&quot;&gt;<br>    &lt;enum key=&quot;0&quot;&gt;Clear&lt;/enum&gt;<br>    &lt;enum key=&quot;1&quot;&gt;Cumulonimbus&lt;/enum&gt;<br>    &lt;enum key=&quot;2&quot;&gt;Stratus&lt;/enum&gt;<br>    &lt;enum key=&quot;3&quot;&gt;Stratocumulus&lt;/enum&gt;<br>    &lt;enum key=&quot;4&quot;&gt;Cumulus&lt;/enum&gt;<br>    &lt;enum key=&quot;5&quot;&gt;Altostratus&lt;/enum&gt;<br>    &lt;enum key=&quot;6&quot;&gt;Nimbostratus&lt;/enum&gt;<br>    &lt;enum key=&quot;7&quot;&gt;Altocumulus&lt;/enum&gt;<br>    &lt;enum key=&quot;8&quot;&gt;Cirrostratus&lt;/enum&gt;<br>    &lt;enum key=&quot;9&quot;&gt;Cirrocumulus&lt;/enum&gt;<br>    &lt;enum key=&quot;10&quot;&gt;Cirrus&lt;/enum&gt;<br>    &lt;enum key=&quot;255&quot;&gt;Missing&lt;/enum&gt;<br>  &lt;/enumTypedef&gt;<br>  &lt;dimension name=&quot;station&quot; length=&quot;5&quot; /&gt;<br>  &lt;variable name=&quot;primary_cloud&quot; shape=&quot;station&quot; type=&quot;enum1&quot;&gt;<br>    &lt;attribute name=&quot;_FillValue&quot; value=&quot;Missing&quot; /&gt;<br>  &lt;/variable&gt;<br>&lt;/netcdf&gt;</pre>
<h3><B>remove Element </B></h3>

<P> The remove element is used to remove attribute, dimension, variable or group objects that are in the referenced dataset. Place the remove element in the
  container of the object to be removed. </P>
<pre>  &lt;xsd:element name=&quot;remove&quot;&gt;<br>    &lt;xsd:complexType&gt;<br>(1)   &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;
(2)   &lt;xsd:attribute name=&quot;type&quot; type=&quot;ObjectType&quot; use=&quot;required&quot;/&gt;<br>    &lt;/xsd:complexType&gt;<br>  &lt;/xsd:element&gt;</pre>
<pre> &lt;xsd:simpleType name=&quot;ObjectType&quot;&gt;
   &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;
     &lt;xsd:enumeration value=&quot;attribute&quot;/&gt;
     &lt;xsd:enumeration value=&quot;dimension&quot;/&gt;
     &lt;xsd:enumeration value=&quot;variable&quot;/&gt;
     &lt;xsd:enumeration value=&quot;group&quot;/&gt;
   &lt;/xsd:restriction&gt;
 &lt;/xsd:simpleType&gt;</pre>
<ol>
  <li>The name of the object to remove</li>
  <li>The type of the object to remove: attribute, dimension, variable or group.</li>
</ol>
<h3>logical view Elements </h3>
<p><em>(since version 4.4)</em></p>

<p>These allow a variable to be a <em><strong>logical view</strong></em> of the original variable. Only one of the logical views can be used per variable.</p>
<pre> &lt;!-- logical view: use only a section of original  --&gt;
 &lt;xsd:element name=&quot;logicalSection&quot;&gt;
   &lt;xsd:complexType&gt;
     &lt;xsd:attribute name=&quot;section&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;  &lt;!-- creates anonymous dimensions --&gt;
   &lt;/xsd:complexType&gt;
 &lt;/xsd:element&gt;
   
 &lt;xsd:element name=&quot;logicalSlice&quot;&gt;
   &lt;xsd:complexType&gt;
     &lt;xsd:attribute name=&quot;dimName&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;
     &lt;xsd:attribute name=&quot;index&quot; type=&quot;xsd:int&quot; use=&quot;required&quot;/&gt;
   &lt;/xsd:complexType&gt;
 &lt;/xsd:element&gt;

 &lt;xsd:element name=&quot;logicalReduce&quot;&gt;
   &lt;xsd:complexType&gt;
     &lt;xsd:attribute name=&quot;dimNames&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;
   &lt;/xsd:complexType&gt;
 &lt;/xsd:element&gt;</pre>
<h3>logicalReduce <a name="logicalReduce"></a>example: </h3>
<p>The original variable has  dimensions of length=1 named &quot;latitude&quot; and &quot;longitude&quot; :</p>
<pre>&lt;dimension name=&quot;time&quot; length=&quot;143&quot; /&gt;<br>&lt;dimension name=&quot;pressure&quot; length=&quot;63&quot; /&gt;<br>&lt;dimension name=&quot;latitude&quot; length=&quot;1&quot; /&gt;<br>&lt;dimension name=&quot;longitude&quot; length=&quot;1&quot; /&gt;

&lt;variable name=&quot;temperature&quot; shape=&quot;time pressure latitude longitude&quot; type=&quot;float&quot;&gt;
  &lt;attribute name=&quot;long_name&quot; value=&quot;Sea Temperature&quot; /&gt;
  &lt;attribute name=&quot;units&quot; value=&quot;Celsius&quot; /&gt;
&lt;/variable&gt;</pre>
<p>Here is the NcML to remove them:</p>
<pre>&lt;variable name=&quot;temperature&quot;&gt;
  &lt;logicalReduce dimNames=&quot;latitude longitude&quot; /&gt;
&lt;/variable&gt;
</pre>
<hr>
<p><strong><em>Everything following pertains to aggregation, and can be ignored if you are not using aggregation.</em></strong></p>

<h3><a name="aggregation"></a>aggregation Element</h3>

<p>The aggregation element allows multiple datasets to be combined into a single logical dataset. There can only be one aggregation element in a netcdf
  element. </p>
<pre>
&lt;xsd:element name=&quot;aggregation&quot;&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:sequence&gt;
<strong>(1)</strong>  &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
      &lt;xsd:element ref=&quot;group&quot;/&gt;<br>      &lt;xsd:element ref=&quot;dimension&quot;/&gt;<br>      &lt;xsd:element ref=&quot;variable&quot;/&gt;<br>      &lt;xsd:element ref=&quot;attribute&quot;/&gt;<br>      &lt;xsd:element ref=&quot;remove&quot;/&gt;<br>     &lt;/xsd:choice&gt;

<strong>(2)</strong>  &lt;xsd:element name=&quot;variableAgg&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
      &lt;xsd:complexType&gt;
       &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;
      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;
<strong>(3) </strong>&lt;xsd:element ref=&quot;promoteGlobalAttribute&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br><strong>(4)</strong>  &lt;xsd:element ref=&quot;cacheVariable&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
<strong>(5)</strong>  &lt;xsd:element ref=&quot;netcdf&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
<strong>(6)</strong>  &lt;xsd:element name=&quot;scan&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
      &lt;xsd:complexType&gt;
<strong>(7)</strong>    &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;
<strong>(8)</strong>    &lt;xsd:attribute name=&quot;regExp&quot; type=&quot;xsd:string&quot; /&gt;
(<strong>9)</strong>    &lt;xsd:attribute name=&quot;suffix&quot; type=&quot;xsd:string&quot; /&gt;<strong>
(10)</strong>   &lt;xsd:attribute name=&quot;subdirs&quot; type=&quot;xsd:boolean&quot; default=&quot;true&quot;/&gt;
<strong>(11)</strong>   &lt;xsd:attribute name=&quot;olderThan&quot; type=&quot;xsd:string&quot; /&gt;
<strong>(12)</strong>   &lt;xsd:attribute name=&quot;dateFormatMark&quot; type=&quot;xsd:string&quot; /&gt;
<strong>(13)</strong>   &lt;xsd:attribute name=&quot;enhance&quot; type=&quot;xsd:string&quot;/&gt;
      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;

<strong>(14)</strong> &lt;xsd:element name=&quot;scanFmrc&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
      &lt;xsd:complexType&gt;
<strong>(7)</strong>    &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:string&quot; <strong>
(8)</strong>    &lt;xsd:attribute name=&quot;regExp&quot; type=&quot;xsd:string&quot; /&gt;use=&quot;required&quot;/&gt;
<strong>(9)</strong>    &lt;xsd:attribute name=&quot;suffix&quot; type=&quot;xsd:string&quot; /&gt;
<strong>(10)</strong>   &lt;xsd:attribute name=&quot;subdirs&quot; type=&quot;xsd:boolean&quot; default=&quot;true&quot;/&gt;
<strong>(11)</strong>   &lt;xsd:attribute name=&quot;olderThan&quot; type=&quot;xsd:string&quot; /&gt;

<strong>(15)</strong>   &lt;xsd:attribute name=&quot;runDateMatcher&quot; type=&quot;xsd:string&quot; /&gt;
<strong> </strong>   &lt;xsd:attribute name=&quot;forecastDateMatcher&quot; type=&quot;xsd:string&quot; /&gt;
<strong> </strong>   &lt;xsd:attribute name=&quot;forecastOffsetMatcher&quot; type=&quot;xsd:string&quot; /&gt;<br>      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
    
<strong>(16)</strong> &lt;xsd:attribute name=&quot;type&quot; type=&quot;AggregationType&quot; use=&quot;required&quot;/&gt;
<strong>(17)</strong> &lt;xsd:attribute name=&quot;dimName&quot; type=&quot;xsd:token&quot; /&gt;
<strong>(18)</strong> &lt;xsd:attribute name=&quot;recheckEvery&quot; type=&quot;xsd:string&quot; /&gt;
<strong>(19)</strong> &lt;xsd:attribute name=&quot;timeUnitsChange&quot; type=&quot;xsd:boolean&quot;/&gt;
<br>
      &lt;!-- fmrc only  --&gt;<br><strong>(20)</strong> &lt;xsd:attribute name=&quot;fmrcDefinition&quot; type=&quot;xsd:string&quot; /&gt;<br>
&lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</pre>
<ol>
  <li>Elements <em><strong>inside</strong></em> the &lt;aggregation&gt; get applied to each dataset in the aggregation, before it is aggregated. Elements
    <em><strong>outside</strong></em> the &lt;aggregation&gt; get applied to the aggregated dataset.
  </li>
  <li>For <em><strong>joinNew</strong></em> aggregation types, each variable to be aggregated must be explicitly listed in a
    <em><strong>variableAgg</strong></em> element.
  </li>
  <li>Optionally specify global attributes to promote to a variable (outer aggregations only) with a
    <a href="#promoteGlobalAttribute">promoteGlobalAttribute</a> element.
  </li>
  <li>Specify which variables should be cached (outer aggregation only) with a <a href="#cacheVariable">cacheVariable</a> element.</li>
  <li>Nested <strong>netcdf</strong> datasets can be explicitly listed.</li>
  <li>Nested netcdf datasets can be implictly specified with a <strong>scan</strong> element.</li>
  <li>The scan directory <strong>location</strong>.</li>
  <li>If you specify a <strong>regExp</strong>, only files with whose full pathnames match the <a href="#regexp">regular expression</a> will be included.</li>
  <li>If you specify a <strong>suffix</strong>, only files with that ending will be included. A <strong>regExp</strong> attribute will override, that is, you
    cant specify both.
  </li>
  <li>You can optionally specify if the scan should descend into <strong>subdir</strong>ectories (default true).</li>
  <li>If <strong>olderThan</strong> attribute is present, only files whose last modified date are older than this amount of time will be included. This is a way
    to exclude files that are still being written. This must be a <a href="http://www.unidata.ucar.edu/software/udunits/">udunit</a> time such as &quot;5 min&quot;
    or &quot;1 hour&quot;.
  </li>
  <li>A <strong>dateFormatMark</strong> is used on <strong><em>joinNew</em></strong> types to create date coordinate values out of the filename. It consists of
    a section of text, a '#' marking character, then a java.text.<a href="#SimpleDateFormat">SimpleDateFormat</a> string. The number of characters before the #
    is skipped in the filename, then the next part of the filename must match the SimpleDateFormat string. You can ignore trailing text. For example:
    <pre>
        Filename: SUPER-NATIONAL_1km_SFC-T_20051206_2300.gini 
 DateFormatMark: SUPER-NATIONAL_1km_SFC-T_#yyyyMMdd_HHmm</pre>
    <p><strong>Note that the dateFormatMark works on the name of the file, without the directories!!</strong></p>

    <p>A <strong>dateFormatMark</strong> can be used on a <strong><em>joinExisting</em> </strong>type only if there is a single time in each file of the
      aggregation, in which case the coordinate values of the time can be created from the filename, instead of having to open each file and read it.</p>
  </li>
  <li> You can optionally specify that the files should be opened in <a href="#enhance">enhanced mode</a> (default is <em>NetcdfDataset.EnhanceMode.None</em>).
    Generally you should do this if the ncml needs to operate on the datset after the CoordSysBuilder has augmented it. Otherwise, you should not enhance.
  </li>
  <li>A specialized scanFmrc element can be used for a <em><strong><a href="FmrcAggregation.html#forecastModelRunSingleCollection">forecastModelRunSingleCollection</a>
  </strong></em>aggregation, where forecast model run data is stored in multiple files, with one forecast time per file.
  </li>
  <li> For scanFmrc, the run date and the forecast date is extracted from the file pathname using a <strong>runDateMatcher </strong>and either a <strong>forecastDateMatcher </strong>or
    a<strong> forecastOffsetMatcher </strong>attribute<strong>. </strong>All of these require matching a specific string in the file's pathname and then
    matching a date or hour offset immediately before or after the match. The match is specified by placing it between '#' marking characters. The <strong>runDateMatcher </strong>and
    <strong>forecastDateMatcher </strong>has a java.text.<a href="#SimpleDateFormat">SimpleDateFormat</a> string before or after the match, while a <strong>forecastOffsetMatcher</strong>
    counts the number of 'H' characters, and extracts an hour offset from the run date. For example:
    <pre>     
             Filename:  gfs_3_20060706_0300_006.grb 
       runDateMatcher: #gfs_3_#yyyyMMdd_HH
forecastOffsetMatcher:                     HHH#.grb#</pre>

    <p>will extract the run date 2006-07-06T03:00:00Z, and the forecast offset &quot;6 hours&quot;. </p>
  </li>
  <li>You must specify an aggregation type.</li>
  <li>For all types except <em><strong>joinUnion</strong></em>, you must specify the dimension name to join.</li>
  <li><em><strong>The recheckEvery attribute only applies when using a scan element</strong>.</em> When you are using scan elements on a set of files that may
    change, and you are using caching, set <strong>recheckEvery</strong> to a valid <a href="http://www.unidata.ucar.edu/software/udunits/">udunit</a> time
    value, like &quot;10 min&quot;, &quot;1 hour&quot;, &quot;30 days&quot;, etc. Whenever the dataset is reacquired from the cache, the directories will be
    rescanned if <strong>recheckEvery</strong> amount of time has elapsed since the last time it was scanned. If you do not specify a recheckEvery attribute,
    the collection will be assumed to be non-changing.
    <p>The<strong> recheckEvery</strong> attribute specifies how out-of-date you are willing to allow your changing datasets to be, not how often the data
      changes. If you want updates to be seen within 5 min, use 5 minutes here, regardless of the frequency of updating.</p>
  </li>
  <li>Only for <strong><em>joinExisting</em> </strong>and<strong> <em>forecastModelRunCollection</em></strong> types: if <strong>timeUnitsChange</strong> is set
    to true, the units of the joined coordinate variable may change, so examine them and do any appropriate conversion so that the aggregated coordinate values
    have consistent units.
  </li>
  <li>Experimental, do not use. <font color="#990000"><br>
  </font></li>
</ol>
<h3>AggregationType Type</h3>
<pre> &lt;!-- type of aggregation --&gt;
 &lt;xsd:simpleType name=&quot;AggregationType&quot;&gt;
  &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;
   &lt;xsd:enumeration value=&quot;forecastModelRunCollection&quot;/&gt;<br>   &lt;xsd:enumeration value=&quot;forecastModelRunSingleCollection&quot;/&gt;
   &lt;xsd:enumeration value=&quot;joinExisting&quot;/&gt;
   &lt;xsd:enumeration value=&quot;joinNew&quot;/&gt;
   &lt;xsd:enumeration value=&quot;tiled&quot;/&gt;
   &lt;xsd:enumeration value=&quot;union&quot;/&gt;
  &lt;/xsd:restriction&gt;
 &lt;/xsd:simpleType&gt;</pre>
<p> The allowable aggregation types. The <em>forecastModelRunCollection, forecastModelRunSingleCollection, joinExisting </em>and<em> joinNew</em> aggregation
  types are called <strong><em>outer aggregations</em></strong> because they work on the outer (first) dimension.<br>
</p>

<h3><strong> promoteGlobalAttribute<a name="promoteGlobalAttribute"></a> Element</strong></h3>
<pre>  &lt;!-- promote global attribute to variable --&gt;
  &lt;xsd:element name=&quot;promoteGlobalAttribute&quot;&gt;
   &lt;xsd:complexType&gt;
<strong>(1)</strong>  &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;
<strong>(2)</strong>  &lt;xsd:attribute name=&quot;orgName&quot; type=&quot;xsd:string&quot;/&gt;
   &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;<strong>
  </strong></pre>
<ol>
  <li>The name of the variable to be created.</li>
  <li>If the global attribute name is different from the variable name, specify it here.</li>
</ol>
<p>This can be used on <strong>joinNew, joinExisting, </strong>and<strong> forecastModelRunCollection</strong>, aka the <em><strong>outer dimension
  aggregations</strong></em>. A new variable will be added using the aggregation dimension and its type will be taken from the attribute type. If theres more
  than one slice in the file (eg in a <strong>joinExisting), </strong>the attribute value will be repeated for each coordinate in that file.<strong><br>
  </strong></p>

<h3><strong><br>
  cacheVariable<a name="cacheVariable"></a> Element</strong></h3>
<pre>  &lt;!-- cache a Variable for efficiency --&gt;
  &lt;xsd:element name=&quot;cacheVariable&quot;&gt;
   &lt;xsd:complexType&gt;
    &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:token&quot; use=&quot;required&quot;/&gt;
   &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;
</pre>
<p>Not ready to be used in a general way yet.<br>
</p>

<h2>Notes</h2>
<ul>
  <li><font color="#0000FF"> Any attributes of type xsd:token, have trailing and ending spaces
    ignored, and all other spaces or new lines are collapsed to one single
    space. </font></li>
  <li><FONT color=#0000ff>If any attribute or content has the characters "&gt;", "&lt;", """, or "&amp;", they must be encoded using standard XML escape
    sequences &amp;gt;, &amp;lt;, &amp;quot;, &amp;amp; respectively.</FONT></li>
</ul>
<hr>
<h2>The java.text.SimpleDateFormat<a name="SimpleDateFormat" id="SimpleDateFormat"></a></h2>

<p> The following is taken from the javadoc, see <a href="http://java.sun.com/j2se/1.4.2/docs/api/index.html">here</a> for full info. The following pattern
  letters are defined (all other characters from <code>'A'</code> to <code>'Z'</code> and from <code>'a'</code> to <code>'z'</code> are reserved): </p>
<blockquote>
  <table summary="Chart shows pattern letters, date/time component, presentation, and examples." border="0" cellpadding="0" cellspacing="3">
    <tbody>
    <tr bgcolor="#ccccff">
      <th align="left">Letter</th>
      <th align="left">Date or Time Component</th>
      <th align="left">Presentation</th>
      <th align="left">Examples</th>
    </tr>
    <tr>
      <td><code>G</code></td>
      <td>Era designator</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#text">Text</a></td>
      <td><code>AD</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>y</code></td>
      <td>Year</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#year">Year</a></td>
      <td><code>1996</code>; <code>96</code></td>
    </tr>
    <tr>
      <td><code>M</code></td>
      <td>Month in year</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#month">Month</a></td>
      <td><code>July</code>; <code>Jul</code>; <code>07</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>w</code></td>
      <td>Week in year</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>27</code></td>
    </tr>
    <tr>
      <td><code>W</code></td>
      <td>Week in month</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>2</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>D</code></td>
      <td>Day in year</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>189</code></td>
    </tr>
    <tr>
      <td><code>d</code></td>
      <td>Day in month</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>10</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>F</code></td>
      <td>Day of week in month</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>2</code></td>
    </tr>
    <tr>
      <td><code>E</code></td>
      <td>Day in week</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#text">Text</a></td>
      <td><code>Tuesday</code>; <code>Tue</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>a</code></td>
      <td>Am/pm marker</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#text">Text</a></td>
      <td><code>PM</code></td>
    </tr>
    <tr>
      <td><code>H</code></td>
      <td>Hour in day (0-23)</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>0</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>k</code></td>
      <td>Hour in day (1-24)</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>24</code></td>
    </tr>
    <tr>
      <td><code>K</code></td>
      <td>Hour in am/pm (0-11)</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>0</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>h</code></td>
      <td>Hour in am/pm (1-12)</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>12</code></td>
    </tr>
    <tr>
      <td><code>m</code></td>
      <td>Minute in hour</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>30</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>s</code></td>
      <td>Second in minute</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>55</code></td>
    </tr>
    <tr>
      <td><code>S</code></td>
      <td>Millisecond</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
      <td><code>978</code></td>
    </tr>
    <tr bgcolor="#eeeeff">
      <td><code>z</code></td>
      <td>Time zone</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#timezone">General time zone</a></td>
      <td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td>
    </tr>
    <tr>
      <td><code>Z</code></td>
      <td>Time zone</td>
      <td><a href="file:///C:/j2sdk1.4.2/docs/api/java/text/SimpleDateFormat.html#rfc822timezone">RFC 822 time zone</a></td>
      <td><code>-0800</code></td>
    </tr>
    </tbody>
  </table>
  <h4>Examples</h4>
  The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the
  U.S. Pacific Time time zone.
  <blockquote>
    <table summary="Examples of date and time patterns interpreted in the U.S. locale" border="0" cellpadding="0" cellspacing="3">
      <tbody>
      <tr bgcolor="#ccccff">
        <th align="left">Date and Time Pattern</th>
        <th align="left">Result</th>
      </tr>
      <tr>
        <td><code>"yyyy.MM.dd G 'at' HH:mm:ss z"</code></td>
        <td><code>2001.07.04 AD at 12:08:56 PDT</code></td>
      </tr>
      <tr bgcolor="#eeeeff">
        <td><code>"EEE, MMM d, ''yy"</code></td>
        <td><code>Wed, Jul 4, '01</code></td>
      </tr>
      <tr>
        <td><code>"h:mm a"</code></td>
        <td><code>12:08 PM</code></td>
      </tr>
      <tr bgcolor="#eeeeff">
        <td><code>"hh 'o''clock' a, zzzz"</code></td>
        <td><code>12 o'clock PM, Pacific Daylight Time</code></td>
      </tr>
      <tr>
        <td><code>"K:mm a, z"</code></td>
        <td><code>0:08 PM, PDT</code></td>
      </tr>
      <tr bgcolor="#eeeeff">
        <td><code>"yyyyy.MMMMM.dd GGG hh:mm aaa"</code></td>
        <td><code>02001.July.04 AD 12:08 PM</code></td>
      </tr>
      <tr>
        <td><code>"EEE, d MMM yyyy HH:mm:ss Z"</code></td>
        <td><code>Wed, 4 Jul 2001 12:08:56 -0700</code></td>
      </tr>
      <tr bgcolor="#eeeeff">
        <td><code>"yyMMddHHmmssZ"</code></td>
        <td><code>010704120856-0700</code></td>
      </tr>
      </tbody>
    </table>
  </blockquote>
</blockquote>
<hr WIDTH="100%">
<h2><a name="regexp"></a>Regular Expressions : java.util.regexp</h2>

<p>Regular expressions are used in <strong>scan</strong> elements to match filenames to be included in the aggregation. Note that the regexp pattern is matched
  against the <em><strong>full pathname</strong></em> of the file (<em>/dir/file.nc, </em>not<em> file.nc</em>).</p>

<p>When placing regular expressions in NcML, you dont need to use \\ for \, eg use</p>
<pre>  &lt;scan location=&quot;test&quot; regExp=&quot;.*/AG.*\.nc$&quot; /&gt;<br></pre>
<p> instead of <br>
</p>
<pre>  &lt;scan location=&quot;test&quot; regExp=&quot;.*/AG.*\\.nc$&quot; /&gt;<br>
</pre>
<p>This may be confusing if you are used to having to double escape in Java Strings: </p>
<pre>  Pattern.compile(&quot;.*/AG.*\\.nc$&quot;)</pre>
<h3>Examples</h3>
<table width="628" border="1">
  <tr>
    <th width="120" scope="col">Pattern</th>
    <th width="312" scope="col">File Pathname</th>
    <th width="163" scope="col">match?</th>
  </tr>
  <tr>
    <td>
      <strong>.*/AG.*\.nc$</strong>      
    </td>
    <td><p>C:/data/test/AG2006001_2006003_ssta.nc</p>
      <p>C:/data/test/AG2006001_2006003_ssta.ncd</p>
      <p>C:/data/test/PS2006001_2006003_ssta.nc</p>    
    </td>
    <td><p>true</p>
      <p>false</p>
      <p>false</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>Resources:</p>
<ul>
  <li><a href="http://java.sun.com/docs/books/tutorial/essential/regex/">http://java.sun.com/docs/books/tutorial/essential/regex/</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Regular_expression">http://en.wikipedia.org/wiki/Regular_expression</a></li>
  <li><a href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a></li>
</ul>
<hr WIDTH="100%">
<p>&nbsp;</p>
<address>
  <img src="nc.gif" width="64" height="64" alt=""> This document is maintained by <a href="mailto:caron@unidata.ucar.edu">John Caron</a> and was last updated Mar 2015.
</address>
<p>&nbsp;</p>
</BODY>
</HTML>
